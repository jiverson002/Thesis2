========== 1 ==========
(1) FILE: ../../cclient.c LINES:241:8 TOKENS:1404:1455 DIST:0.0

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } int getFDForInput ( ) { ; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( socketFD , & fdvar ) ) { return socketFD ; } if ( isConnected && FD_ISSET ( fileno ( stdin ) , & fdvar ) ) { return fileno ( stdin ) ; } return - 1 ; } void process ( ) { int fdToProcess ; while ( 1 ) { printf ( "$: " ) ; fflush ( stdout ) ; fdToProcess = getFDForInput ( ) ; if ( fdToProcess == fileno ( stdin ) ) { processInput ( ) ; } else { printf ( "\n" ) ; processPacket ( ) ; } } } void processPacket ( ) { uint8_t * packet = malloc ( 1000 ) ; uint8_t * toFree = packet ; int numBytes = 0 ; if ( ( numBytes = myRecv ( socketFD , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { printf ( "Server terminated\n" ) ; close ( socketFD ) ; exit ( 1 ) ; } while ( numBytes > 0 ) { ; } free ( toFree ) ; } void processInput ( ) { int didWork = 0 ; unsigned long inputNum = - 1 ; char * line = ( ( void * ) 0 ) ; char * lineToFree = ( ( void * ) 0 ) ; char * cmd = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; char * dst = ( ( void * ) 0 ) ; getline ( & line , ( size_t * ) & inputNum , stdin ) ; lineToFree = line ; cmd = strtok ( line , " \n\t" ) ; if ( cmd != ( ( void * ) 0 ) ) { if ( strcmp ( cmd , "%E" ) == 0 || strcmp ( cmd , "%e" ) == 0 ) { sendPacketFlag ( 8 , socketFD ) ; didWork = 1 ; } if ( strcmp ( cmd , "%B" ) == 0 || strcmp ( cmd , "%b" ) == 0 ) { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } if ( strcmp ( cmd , "%M" ) == 0 || strcmp ( cmd , "%m" ) == 0 ) { dst = strtok ( ( ( void * ) 0 ) , " \n\t" ) ; if ( dst == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketMssg ( mssg , dst , socketFD ) ; } } didWork = 1 ; } if ( strcmp ( cmd , "%L" ) == 0 || strcmp ( cmd , "%l" ) == 0 ) { sendPacketFlag ( 10 , socketFD ) ; didWork = 1 ; } } free ( lineToFree ) ; if ( didWork == 0 ) { printf ( "Invalid command\n" ) ; } } void processHandles ( int handleNum ) { int i = 0 ; isConnected = 0 ; for ( i = 0 ; i < handleNum ; i ++ ) { getFDForInput ( ) ; processPacket ( ) ; } isConnected = 1 ; } void printBroadcast ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getFirstHandle ( packet , & sender ) ; getBroadCastMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } void printMessage ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getSrcHandle ( packet , & sender ) ; getMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
(2) FILE: ../../cclient.c LINES:250:8 TOKENS:1472:1523 DIST:0.0

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } int getFDForInput ( ) { ; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( socketFD , & fdvar ) ) { return socketFD ; } if ( isConnected && FD_ISSET ( fileno ( stdin ) , & fdvar ) ) { return fileno ( stdin ) ; } return - 1 ; } void process ( ) { int fdToProcess ; while ( 1 ) { printf ( "$: " ) ; fflush ( stdout ) ; fdToProcess = getFDForInput ( ) ; if ( fdToProcess == fileno ( stdin ) ) { processInput ( ) ; } else { printf ( "\n" ) ; processPacket ( ) ; } } } void processPacket ( ) { uint8_t * packet = malloc ( 1000 ) ; uint8_t * toFree = packet ; int numBytes = 0 ; if ( ( numBytes = myRecv ( socketFD , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { printf ( "Server terminated\n" ) ; close ( socketFD ) ; exit ( 1 ) ; } while ( numBytes > 0 ) { ; } free ( toFree ) ; } void processInput ( ) { int didWork = 0 ; unsigned long inputNum = - 1 ; char * line = ( ( void * ) 0 ) ; char * lineToFree = ( ( void * ) 0 ) ; char * cmd = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; char * dst = ( ( void * ) 0 ) ; getline ( & line , ( size_t * ) & inputNum , stdin ) ; lineToFree = line ; cmd = strtok ( line , " \n\t" ) ; if ( cmd != ( ( void * ) 0 ) ) { if ( strcmp ( cmd , "%E" ) == 0 || strcmp ( cmd , "%e" ) == 0 ) { sendPacketFlag ( 8 , socketFD ) ; didWork = 1 ; } if ( strcmp ( cmd , "%B" ) == 0 || strcmp ( cmd , "%b" ) == 0 ) { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } if ( strcmp ( cmd , "%M" ) == 0 || strcmp ( cmd , "%m" ) == 0 ) { dst = strtok ( ( ( void * ) 0 ) , " \n\t" ) ; if ( dst == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketMssg ( mssg , dst , socketFD ) ; } } didWork = 1 ; } if ( strcmp ( cmd , "%L" ) == 0 || strcmp ( cmd , "%l" ) == 0 ) { sendPacketFlag ( 10 , socketFD ) ; didWork = 1 ; } } free ( lineToFree ) ; if ( didWork == 0 ) { printf ( "Invalid command\n" ) ; } } void processHandles ( int handleNum ) { int i = 0 ; isConnected = 0 ; for ( i = 0 ; i < handleNum ; i ++ ) { getFDForInput ( ) ; processPacket ( ) ; } isConnected = 1 ; } void printBroadcast ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getFirstHandle ( packet , & sender ) ; getBroadCastMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } void printMessage ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getSrcHandle ( packet , & sender ) ; getMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } void printHandle ( void * packet ) { char * handle = ( ( void * ) 0 ) ; getFirstHandle ( packet , & handle ) ; printf ( "  -%s\n" , handle ) ; free ( handle ) ; } 
========== 2 ==========
(1) FILE: ../../server.c LINES:119:11 TOKENS:777:837 DIST:0.0

int serverFD ; int * clientFDs = ( ( void * ) 0 ) ; char * * handles = ( ( void * ) 0 ) ; int clientNum = 0 ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { serverFD = tcpServerSetup ( 0 ) ; process ( ) ; return 0 ; } void addClient ( int fd ) { clientNum ++ ; clientFDs = realloc ( clientFDs , sizeof ( int ) * clientNum ) ; clientFDs [ clientNum - 1 ] = fd ; handles = realloc ( handles , sizeof ( char * ) * clientNum ) ; handles [ clientNum - 1 ] = ( ( void * ) 0 ) ; } void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } int getFDForName ( char * name ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( handles [ i ] != ( ( void * ) 0 ) && strcmp ( name , handles [ i ] ) == 0 ) { return clientFDs [ i ] ; } } return - 1 ; } void removeClient ( int fd ) { int i = 0 ; int * newClientFDs ; char * * newHandles ; int foundFD = 0 ; clientNum -- ; newClientFDs = ( int * ) malloc ( sizeof ( int ) * clientNum ) ; newHandles = ( char * * ) malloc ( sizeof ( char * ) * clientNum ) ; for ( i = 0 ; i <= clientNum ; i ++ ) { if ( clientFDs [ i ] != fd ) { if ( ! foundFD ) { newClientFDs [ i ] = clientFDs [ i ] ; newHandles [ i ] = handles [ i ] ; } else { newClientFDs [ i - 1 ] = clientFDs [ i ] ; newHandles [ i - 1 ] = handles [ i ] ; } } else { foundFD = 1 ; if ( handles [ i ] != ( ( void * ) 0 ) ) { printf ( "Bye %s\n" , handles [ i ] ) ; } free ( handles [ i ] ) ; close ( clientFDs [ i ] ) ; } } free ( handles ) ; free ( clientFDs ) ; handles = newHandles ; clientFDs = newClientFDs ; } int getFDForInput ( ) { ; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( serverFD , & fdvar ) ) { return serverFD ; } else { for ( i = 0 ; i < clientNum ; i ++ ) { if ( FD_ISSET ( clientFDs [ i ] , & fdvar ) ) { return clientFDs [ i ] ; } } } return - 1 ; } void acceptClient ( ) { int clientFD = tcpAccept ( serverFD ) ; addClient ( clientFD ) ; } void process ( ) { int fdToProcess ; while ( 1 ) { fdToProcess = getFDForInput ( ) ; if ( fdToProcess == serverFD ) { acceptClient ( ) ; } else { processPacket ( fdToProcess ) ; } } } void processPacket ( int fd ) { uint8_t * packet = malloc ( 1000 ) ; int numBytes = 0 ; if ( ( numBytes = myRecv ( fd , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { removeClient ( fd ) ; } switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } free ( packet ) ; } 
(2) FILE: ../../cclient.c LINES:123:12 TOKENS:843:904 DIST:3.2

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } int getFDForInput ( ) { ; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( socketFD , & fdvar ) ) { return socketFD ; } if ( isConnected && FD_ISSET ( fileno ( stdin ) , & fdvar ) ) { return fileno ( stdin ) ; } return - 1 ; } void process ( ) { int fdToProcess ; while ( 1 ) { printf ( "$: " ) ; fflush ( stdout ) ; fdToProcess = getFDForInput ( ) ; if ( fdToProcess == fileno ( stdin ) ) { processInput ( ) ; } else { printf ( "\n" ) ; processPacket ( ) ; } } } void processPacket ( ) { uint8_t * packet = malloc ( 1000 ) ; uint8_t * toFree = packet ; int numBytes = 0 ; if ( ( numBytes = myRecv ( socketFD , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { printf ( "Server terminated\n" ) ; close ( socketFD ) ; exit ( 1 ) ; } while ( numBytes > 0 ) { ; } free ( toFree ) ; } 
========== 3 ==========
(1) FILE: ../../cclient.c LINES:85:6 TOKENS:592:648 DIST:2.8

char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } 
(2) FILE: ../../cclient.c LINES:50:8 TOKENS:329:385 DIST:0.0

char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } 
========== 4 ==========
(1) FILE: ../../cclient.c LINES:45:10 TOKENS:303:355 DIST:0.0

char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; 
(2) FILE: ../../cclient.c LINES:77:9 TOKENS:543:596 DIST:3.0

char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; 
========== 5 ==========
(1) FILE: ../../server.c LINES:200:9 TOKENS:1234:1284 DIST:0.0

void sendPacketHandle ( int socket , char * handle ) { int hLen = strlen ( handle ) ; void * packet = makePacketHandle ( 12 , hLen , handle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
(2) FILE: ../../cclient.c LINES:22:8 TOKENS:115:166 DIST:1.4

void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
========== 6 ==========
(1) FILE: ../../server.c LINES:136:13 TOKENS:868:918 DIST:0.0

switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } 
(2) FILE: ../../server.c LINES:142:15 TOKENS:893:945 DIST:3.0

case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } 
========== 7 ==========
(1) FILE: ../../cclient.c LINES:19:10 TOKENS:103:161 DIST:0.0

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
(2) FILE: ../../server.c LINES:196:10 TOKENS:1216:1277 DIST:2.6

int serverFD ; int * clientFDs = ( ( void * ) 0 ) ; char * * handles = ( ( void * ) 0 ) ; int clientNum = 0 ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { serverFD = tcpServerSetup ( 0 ) ; process ( ) ; return 0 ; } void addClient ( int fd ) { clientNum ++ ; clientFDs = realloc ( clientFDs , sizeof ( int ) * clientNum ) ; clientFDs [ clientNum - 1 ] = fd ; handles = realloc ( handles , sizeof ( char * ) * clientNum ) ; handles [ clientNum - 1 ] = ( ( void * ) 0 ) ; } void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } int getFDForName ( char * name ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( handles [ i ] != ( ( void * ) 0 ) && strcmp ( name , handles [ i ] ) == 0 ) { return clientFDs [ i ] ; } } return - 1 ; } void removeClient ( int fd ) { int i = 0 ; int * newClientFDs ; char * * newHandles ; int foundFD = 0 ; clientNum -- ; newClientFDs = ( int * ) malloc ( sizeof ( int ) * clientNum ) ; newHandles = ( char * * ) malloc ( sizeof ( char * ) * clientNum ) ; for ( i = 0 ; i <= clientNum ; i ++ ) { if ( clientFDs [ i ] != fd ) { if ( ! foundFD ) { newClientFDs [ i ] = clientFDs [ i ] ; newHandles [ i ] = handles [ i ] ; } else { newClientFDs [ i - 1 ] = clientFDs [ i ] ; newHandles [ i - 1 ] = handles [ i ] ; } } else { foundFD = 1 ; if ( handles [ i ] != ( ( void * ) 0 ) ) { printf ( "Bye %s\n" , handles [ i ] ) ; } free ( handles [ i ] ) ; close ( clientFDs [ i ] ) ; } } free ( handles ) ; free ( clientFDs ) ; handles = newHandles ; clientFDs = newClientFDs ; } int getFDForInput ( ) { ; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( serverFD , & fdvar ) ) { return serverFD ; } else { for ( i = 0 ; i < clientNum ; i ++ ) { if ( FD_ISSET ( clientFDs [ i ] , & fdvar ) ) { return clientFDs [ i ] ; } } } return - 1 ; } void acceptClient ( ) { int clientFD = tcpAccept ( serverFD ) ; addClient ( clientFD ) ; } void process ( ) { int fdToProcess ; while ( 1 ) { fdToProcess = getFDForInput ( ) ; if ( fdToProcess == serverFD ) { acceptClient ( ) ; } else { processPacket ( fdToProcess ) ; } } } void processPacket ( int fd ) { uint8_t * packet = malloc ( 1000 ) ; int numBytes = 0 ; if ( ( numBytes = myRecv ( fd , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { removeClient ( fd ) ; } switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } free ( packet ) ; } void broadCast ( int senderFD , void * packet ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] != senderFD ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } } } } void forwardMessage ( int senderFD , void * packet ) { int i = 0 ; char * dest = ( ( void * ) 0 ) ; int sent = 0 ; getDestHandle ( packet , & dest ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( strcmp ( dest , handles [ i ] ) == 0 ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } sent = 1 ; break ; } } if ( sent == 0 ) { sendPacketFlag ( 7 , senderFD ) ; } free ( dest ) ; } void sendPacketHandleAck ( uint8_t flag , int socket ) { ; headerSetLen ( ( ) & head , ( uint16_t ) ( sizeof ( packetHandleAck ) - sizeof ( header ) ) ) ; packetHandleAckSetNum ( & head , clientNum ) ; head . head . flag = flag ; if ( mySend ( socket , & head , sizeof ( packetHandleAck ) , 0 ) < 0 ) { perror ( "Flag Packet Send" ) ; exit ( 1 ) ; } } void sendPacketHandle ( int socket , char * handle ) { int hLen = strlen ( handle ) ; void * packet = makePacketHandle ( 12 , hLen , handle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
========== 8 ==========
(1) FILE: ../../cclient.c LINES:239:9 TOKENS:1384:1451 DIST:0.0

void printBroadcast ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getFirstHandle ( packet , & sender ) ; getBroadCastMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
(2) FILE: ../../cclient.c LINES:248:9 TOKENS:1452:1519 DIST:0.0

void printMessage ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getSrcHandle ( packet , & sender ) ; getMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
========== 9 ==========
(1) FILE: ../../cclient.c LINES:38:5 TOKENS:228:281 DIST:0.0

char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } 
(2) FILE: ../../cclient.c LINES:70:6 TOKENS:478:536 DIST:3.5

char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } 
========== 10 ==========
(1) FILE: ../../cclient.c LINES:202:7 TOKENS:1165:1224 DIST:3.3

if ( strcmp ( cmd , "%E" ) == 0 || strcmp ( cmd , "%e" ) == 0 ) { sendPacketFlag ( 8 , socketFD ) ; didWork = 1 ; } if ( strcmp ( cmd , "%B" ) == 0 || strcmp ( cmd , "%b" ) == 0 ) { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } if ( strcmp ( cmd , "%M" ) == 0 || strcmp ( cmd , "%m" ) == 0 ) { dst = strtok ( ( ( void * ) 0 ) , " \n\t" ) ; if ( dst == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketMssg ( mssg , dst , socketFD ) ; } } didWork = 1 ; } 
(2) FILE: ../../cclient.c LINES:195:7 TOKENS:1103:1162 DIST:0.0

if ( strcmp ( cmd , "%E" ) == 0 || strcmp ( cmd , "%e" ) == 0 ) { sendPacketFlag ( 8 , socketFD ) ; didWork = 1 ; } if ( strcmp ( cmd , "%B" ) == 0 || strcmp ( cmd , "%b" ) == 0 ) { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } 
========== 11 ==========
(1) FILE: ../../cclient.c LINES:101:4 TOKENS:695:747 DIST:2.4

; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } 
(2) FILE: ../../server.c LINES:93:4 TOKENS:610:666 DIST:0.0

; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } 
========== 12 ==========
(1) FILE: ../../server.c LINES:199:8 TOKENS:1227:1282 DIST:0.0

int serverFD ; int * clientFDs = ( ( void * ) 0 ) ; char * * handles = ( ( void * ) 0 ) ; int clientNum = 0 ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { serverFD = tcpServerSetup ( 0 ) ; process ( ) ; return 0 ; } void addClient ( int fd ) { clientNum ++ ; clientFDs = realloc ( clientFDs , sizeof ( int ) * clientNum ) ; clientFDs [ clientNum - 1 ] = fd ; handles = realloc ( handles , sizeof ( char * ) * clientNum ) ; handles [ clientNum - 1 ] = ( ( void * ) 0 ) ; } void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } int getFDForName ( char * name ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( handles [ i ] != ( ( void * ) 0 ) && strcmp ( name , handles [ i ] ) == 0 ) { return clientFDs [ i ] ; } } return - 1 ; } void removeClient ( int fd ) { int i = 0 ; int * newClientFDs ; char * * newHandles ; int foundFD = 0 ; clientNum -- ; newClientFDs = ( int * ) malloc ( sizeof ( int ) * clientNum ) ; newHandles = ( char * * ) malloc ( sizeof ( char * ) * clientNum ) ; for ( i = 0 ; i <= clientNum ; i ++ ) { if ( clientFDs [ i ] != fd ) { if ( ! foundFD ) { newClientFDs [ i ] = clientFDs [ i ] ; newHandles [ i ] = handles [ i ] ; } else { newClientFDs [ i - 1 ] = clientFDs [ i ] ; newHandles [ i - 1 ] = handles [ i ] ; } } else { foundFD = 1 ; if ( handles [ i ] != ( ( void * ) 0 ) ) { printf ( "Bye %s\n" , handles [ i ] ) ; } free ( handles [ i ] ) ; close ( clientFDs [ i ] ) ; } } free ( handles ) ; free ( clientFDs ) ; handles = newHandles ; clientFDs = newClientFDs ; } int getFDForInput ( ) { ; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( serverFD , & fdvar ) ) { return serverFD ; } else { for ( i = 0 ; i < clientNum ; i ++ ) { if ( FD_ISSET ( clientFDs [ i ] , & fdvar ) ) { return clientFDs [ i ] ; } } } return - 1 ; } void acceptClient ( ) { int clientFD = tcpAccept ( serverFD ) ; addClient ( clientFD ) ; } void process ( ) { int fdToProcess ; while ( 1 ) { fdToProcess = getFDForInput ( ) ; if ( fdToProcess == serverFD ) { acceptClient ( ) ; } else { processPacket ( fdToProcess ) ; } } } void processPacket ( int fd ) { uint8_t * packet = malloc ( 1000 ) ; int numBytes = 0 ; if ( ( numBytes = myRecv ( fd , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { removeClient ( fd ) ; } switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } free ( packet ) ; } void broadCast ( int senderFD , void * packet ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] != senderFD ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } } } } void forwardMessage ( int senderFD , void * packet ) { int i = 0 ; char * dest = ( ( void * ) 0 ) ; int sent = 0 ; getDestHandle ( packet , & dest ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( strcmp ( dest , handles [ i ] ) == 0 ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } sent = 1 ; break ; } } if ( sent == 0 ) { sendPacketFlag ( 7 , senderFD ) ; } free ( dest ) ; } void sendPacketHandleAck ( uint8_t flag , int socket ) { ; headerSetLen ( ( ) & head , ( uint16_t ) ( sizeof ( packetHandleAck ) - sizeof ( header ) ) ) ; packetHandleAckSetNum ( & head , clientNum ) ; head . head . flag = flag ; if ( mySend ( socket , & head , sizeof ( packetHandleAck ) , 0 ) < 0 ) { perror ( "Flag Packet Send" ) ; exit ( 1 ) ; } } void sendPacketHandle ( int socket , char * handle ) { int hLen = strlen ( handle ) ; void * packet = makePacketHandle ( 12 , hLen , handle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
(2) FILE: ../../cclient.c LINES:19:10 TOKENS:103:161 DIST:3.2

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
========== 13 ==========
(1) FILE: ../../cclient.c LINES:31:6 TOKENS:169:222 DIST:0.0

void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } 
(2) FILE: ../../cclient.c LINES:63:6 TOKENS:408:463 DIST:3.2

void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } 
========== 14 ==========
(1) FILE: ../../cclient.c LINES:47:10 TOKENS:318:378 DIST:0.0

char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } 
(2) FILE: ../../cclient.c LINES:82:8 TOKENS:583:641 DIST:3.2

char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } 
========== 15 ==========
(1) FILE: ../../cclient.c LINES:245:8 TOKENS:1441:1499 DIST:3.2

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } int getFDForInput ( ) { ; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( socketFD , & fdvar ) ) { return socketFD ; } if ( isConnected && FD_ISSET ( fileno ( stdin ) , & fdvar ) ) { return fileno ( stdin ) ; } return - 1 ; } void process ( ) { int fdToProcess ; while ( 1 ) { printf ( "$: " ) ; fflush ( stdout ) ; fdToProcess = getFDForInput ( ) ; if ( fdToProcess == fileno ( stdin ) ) { processInput ( ) ; } else { printf ( "\n" ) ; processPacket ( ) ; } } } void processPacket ( ) { uint8_t * packet = malloc ( 1000 ) ; uint8_t * toFree = packet ; int numBytes = 0 ; if ( ( numBytes = myRecv ( socketFD , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { printf ( "Server terminated\n" ) ; close ( socketFD ) ; exit ( 1 ) ; } while ( numBytes > 0 ) { ; } free ( toFree ) ; } void processInput ( ) { int didWork = 0 ; unsigned long inputNum = - 1 ; char * line = ( ( void * ) 0 ) ; char * lineToFree = ( ( void * ) 0 ) ; char * cmd = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; char * dst = ( ( void * ) 0 ) ; getline ( & line , ( size_t * ) & inputNum , stdin ) ; lineToFree = line ; cmd = strtok ( line , " \n\t" ) ; if ( cmd != ( ( void * ) 0 ) ) { if ( strcmp ( cmd , "%E" ) == 0 || strcmp ( cmd , "%e" ) == 0 ) { sendPacketFlag ( 8 , socketFD ) ; didWork = 1 ; } if ( strcmp ( cmd , "%B" ) == 0 || strcmp ( cmd , "%b" ) == 0 ) { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } if ( strcmp ( cmd , "%M" ) == 0 || strcmp ( cmd , "%m" ) == 0 ) { dst = strtok ( ( ( void * ) 0 ) , " \n\t" ) ; if ( dst == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketMssg ( mssg , dst , socketFD ) ; } } didWork = 1 ; } if ( strcmp ( cmd , "%L" ) == 0 || strcmp ( cmd , "%l" ) == 0 ) { sendPacketFlag ( 10 , socketFD ) ; didWork = 1 ; } } free ( lineToFree ) ; if ( didWork == 0 ) { printf ( "Invalid command\n" ) ; } } void processHandles ( int handleNum ) { int i = 0 ; isConnected = 0 ; for ( i = 0 ; i < handleNum ; i ++ ) { getFDForInput ( ) ; processPacket ( ) ; } isConnected = 1 ; } void printBroadcast ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getFirstHandle ( packet , & sender ) ; getBroadCastMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } void printMessage ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getSrcHandle ( packet , & sender ) ; getMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
(2) FILE: ../../cclient.c LINES:235:9 TOKENS:1374:1431 DIST:0.0

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } int getFDForInput ( ) { ; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( socketFD , & fdvar ) ) { return socketFD ; } if ( isConnected && FD_ISSET ( fileno ( stdin ) , & fdvar ) ) { return fileno ( stdin ) ; } return - 1 ; } void process ( ) { int fdToProcess ; while ( 1 ) { printf ( "$: " ) ; fflush ( stdout ) ; fdToProcess = getFDForInput ( ) ; if ( fdToProcess == fileno ( stdin ) ) { processInput ( ) ; } else { printf ( "\n" ) ; processPacket ( ) ; } } } void processPacket ( ) { uint8_t * packet = malloc ( 1000 ) ; uint8_t * toFree = packet ; int numBytes = 0 ; if ( ( numBytes = myRecv ( socketFD , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { printf ( "Server terminated\n" ) ; close ( socketFD ) ; exit ( 1 ) ; } while ( numBytes > 0 ) { ; } free ( toFree ) ; } void processInput ( ) { int didWork = 0 ; unsigned long inputNum = - 1 ; char * line = ( ( void * ) 0 ) ; char * lineToFree = ( ( void * ) 0 ) ; char * cmd = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; char * dst = ( ( void * ) 0 ) ; getline ( & line , ( size_t * ) & inputNum , stdin ) ; lineToFree = line ; cmd = strtok ( line , " \n\t" ) ; if ( cmd != ( ( void * ) 0 ) ) { if ( strcmp ( cmd , "%E" ) == 0 || strcmp ( cmd , "%e" ) == 0 ) { sendPacketFlag ( 8 , socketFD ) ; didWork = 1 ; } if ( strcmp ( cmd , "%B" ) == 0 || strcmp ( cmd , "%b" ) == 0 ) { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } if ( strcmp ( cmd , "%M" ) == 0 || strcmp ( cmd , "%m" ) == 0 ) { dst = strtok ( ( ( void * ) 0 ) , " \n\t" ) ; if ( dst == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketMssg ( mssg , dst , socketFD ) ; } } didWork = 1 ; } if ( strcmp ( cmd , "%L" ) == 0 || strcmp ( cmd , "%l" ) == 0 ) { sendPacketFlag ( 10 , socketFD ) ; didWork = 1 ; } } free ( lineToFree ) ; if ( didWork == 0 ) { printf ( "Invalid command\n" ) ; } } void processHandles ( int handleNum ) { int i = 0 ; isConnected = 0 ; for ( i = 0 ; i < handleNum ; i ++ ) { getFDForInput ( ) ; processPacket ( ) ; } isConnected = 1 ; } void printBroadcast ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getFirstHandle ( packet , & sender ) ; getBroadCastMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
========== 16 ==========
(1) FILE: ../../cclient.c LINES:73:12 TOKENS:514:591 DIST:2.8

{ memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } 
(2) FILE: ../../cclient.c LINES:40:12 TOKENS:253:332 DIST:0.0

while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } 
========== 17 ==========
(1) FILE: ../../cclient.c LINES:22:9 TOKENS:111:167 DIST:2.0

void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
(2) FILE: ../../server.c LINES:196:10 TOKENS:1216:1277 DIST:2.0

int serverFD ; int * clientFDs = ( ( void * ) 0 ) ; char * * handles = ( ( void * ) 0 ) ; int clientNum = 0 ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { serverFD = tcpServerSetup ( 0 ) ; process ( ) ; return 0 ; } void addClient ( int fd ) { clientNum ++ ; clientFDs = realloc ( clientFDs , sizeof ( int ) * clientNum ) ; clientFDs [ clientNum - 1 ] = fd ; handles = realloc ( handles , sizeof ( char * ) * clientNum ) ; handles [ clientNum - 1 ] = ( ( void * ) 0 ) ; } void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } int getFDForName ( char * name ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( handles [ i ] != ( ( void * ) 0 ) && strcmp ( name , handles [ i ] ) == 0 ) { return clientFDs [ i ] ; } } return - 1 ; } void removeClient ( int fd ) { int i = 0 ; int * newClientFDs ; char * * newHandles ; int foundFD = 0 ; clientNum -- ; newClientFDs = ( int * ) malloc ( sizeof ( int ) * clientNum ) ; newHandles = ( char * * ) malloc ( sizeof ( char * ) * clientNum ) ; for ( i = 0 ; i <= clientNum ; i ++ ) { if ( clientFDs [ i ] != fd ) { if ( ! foundFD ) { newClientFDs [ i ] = clientFDs [ i ] ; newHandles [ i ] = handles [ i ] ; } else { newClientFDs [ i - 1 ] = clientFDs [ i ] ; newHandles [ i - 1 ] = handles [ i ] ; } } else { foundFD = 1 ; if ( handles [ i ] != ( ( void * ) 0 ) ) { printf ( "Bye %s\n" , handles [ i ] ) ; } free ( handles [ i ] ) ; close ( clientFDs [ i ] ) ; } } free ( handles ) ; free ( clientFDs ) ; handles = newHandles ; clientFDs = newClientFDs ; } int getFDForInput ( ) { ; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( serverFD , & fdvar ) ) { return serverFD ; } else { for ( i = 0 ; i < clientNum ; i ++ ) { if ( FD_ISSET ( clientFDs [ i ] , & fdvar ) ) { return clientFDs [ i ] ; } } } return - 1 ; } void acceptClient ( ) { int clientFD = tcpAccept ( serverFD ) ; addClient ( clientFD ) ; } void process ( ) { int fdToProcess ; while ( 1 ) { fdToProcess = getFDForInput ( ) ; if ( fdToProcess == serverFD ) { acceptClient ( ) ; } else { processPacket ( fdToProcess ) ; } } } void processPacket ( int fd ) { uint8_t * packet = malloc ( 1000 ) ; int numBytes = 0 ; if ( ( numBytes = myRecv ( fd , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { removeClient ( fd ) ; } switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } free ( packet ) ; } void broadCast ( int senderFD , void * packet ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] != senderFD ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } } } } void forwardMessage ( int senderFD , void * packet ) { int i = 0 ; char * dest = ( ( void * ) 0 ) ; int sent = 0 ; getDestHandle ( packet , & dest ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( strcmp ( dest , handles [ i ] ) == 0 ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } sent = 1 ; break ; } } if ( sent == 0 ) { sendPacketFlag ( 7 , senderFD ) ; } free ( dest ) ; } void sendPacketHandleAck ( uint8_t flag , int socket ) { ; headerSetLen ( ( ) & head , ( uint16_t ) ( sizeof ( packetHandleAck ) - sizeof ( header ) ) ) ; packetHandleAckSetNum ( & head , clientNum ) ; head . head . flag = flag ; if ( mySend ( socket , & head , sizeof ( packetHandleAck ) , 0 ) < 0 ) { perror ( "Flag Packet Send" ) ; exit ( 1 ) ; } } void sendPacketHandle ( int socket , char * handle ) { int hLen = strlen ( handle ) ; void * packet = makePacketHandle ( 12 , hLen , handle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
========== 18 ==========
(1) FILE: ../../cclient.c LINES:20:9 TOKENS:108:161 DIST:3.0

int socketFD = 0 ; int isConnected = 0 ; char * myHandle = ( ( void * ) 0 ) ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { if ( argc != 4 ) { printf ( "usage: %s handle host-name port-number \n" , argv [ 0 ] ) ; exit ( 1 ) ; } socketFD = tcpClientSetup ( argv [ 2 ] , argv [ 3 ] ) ; myHandle = argv [ 1 ] ; sendPacketConnection ( socketFD ) ; process ( ) ; return 0 ; } void sendPacketConnection ( int socket ) { int hLen = strlen ( myHandle ) ; void * packet = makePacketHandle ( 1 , hLen , myHandle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
(2) FILE: ../../server.c LINES:199:7 TOKENS:1224:1277 DIST:0.0

int serverFD ; int * clientFDs = ( ( void * ) 0 ) ; char * * handles = ( ( void * ) 0 ) ; int clientNum = 0 ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { serverFD = tcpServerSetup ( 0 ) ; process ( ) ; return 0 ; } void addClient ( int fd ) { clientNum ++ ; clientFDs = realloc ( clientFDs , sizeof ( int ) * clientNum ) ; clientFDs [ clientNum - 1 ] = fd ; handles = realloc ( handles , sizeof ( char * ) * clientNum ) ; handles [ clientNum - 1 ] = ( ( void * ) 0 ) ; } void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } int getFDForName ( char * name ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( handles [ i ] != ( ( void * ) 0 ) && strcmp ( name , handles [ i ] ) == 0 ) { return clientFDs [ i ] ; } } return - 1 ; } void removeClient ( int fd ) { int i = 0 ; int * newClientFDs ; char * * newHandles ; int foundFD = 0 ; clientNum -- ; newClientFDs = ( int * ) malloc ( sizeof ( int ) * clientNum ) ; newHandles = ( char * * ) malloc ( sizeof ( char * ) * clientNum ) ; for ( i = 0 ; i <= clientNum ; i ++ ) { if ( clientFDs [ i ] != fd ) { if ( ! foundFD ) { newClientFDs [ i ] = clientFDs [ i ] ; newHandles [ i ] = handles [ i ] ; } else { newClientFDs [ i - 1 ] = clientFDs [ i ] ; newHandles [ i - 1 ] = handles [ i ] ; } } else { foundFD = 1 ; if ( handles [ i ] != ( ( void * ) 0 ) ) { printf ( "Bye %s\n" , handles [ i ] ) ; } free ( handles [ i ] ) ; close ( clientFDs [ i ] ) ; } } free ( handles ) ; free ( clientFDs ) ; handles = newHandles ; clientFDs = newClientFDs ; } int getFDForInput ( ) { ; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( serverFD , & fdvar ) ) { return serverFD ; } else { for ( i = 0 ; i < clientNum ; i ++ ) { if ( FD_ISSET ( clientFDs [ i ] , & fdvar ) ) { return clientFDs [ i ] ; } } } return - 1 ; } void acceptClient ( ) { int clientFD = tcpAccept ( serverFD ) ; addClient ( clientFD ) ; } void process ( ) { int fdToProcess ; while ( 1 ) { fdToProcess = getFDForInput ( ) ; if ( fdToProcess == serverFD ) { acceptClient ( ) ; } else { processPacket ( fdToProcess ) ; } } } void processPacket ( int fd ) { uint8_t * packet = malloc ( 1000 ) ; int numBytes = 0 ; if ( ( numBytes = myRecv ( fd , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { removeClient ( fd ) ; } switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } free ( packet ) ; } void broadCast ( int senderFD , void * packet ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] != senderFD ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } } } } void forwardMessage ( int senderFD , void * packet ) { int i = 0 ; char * dest = ( ( void * ) 0 ) ; int sent = 0 ; getDestHandle ( packet , & dest ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( strcmp ( dest , handles [ i ] ) == 0 ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } sent = 1 ; break ; } } if ( sent == 0 ) { sendPacketFlag ( 7 , senderFD ) ; } free ( dest ) ; } void sendPacketHandleAck ( uint8_t flag , int socket ) { ; headerSetLen ( ( ) & head , ( uint16_t ) ( sizeof ( packetHandleAck ) - sizeof ( header ) ) ) ; packetHandleAckSetNum ( & head , clientNum ) ; head . head . flag = flag ; if ( mySend ( socket , & head , sizeof ( packetHandleAck ) , 0 ) < 0 ) { perror ( "Flag Packet Send" ) ; exit ( 1 ) ; } } void sendPacketHandle ( int socket , char * handle ) { int hLen = strlen ( handle ) ; void * packet = makePacketHandle ( 12 , hLen , handle ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Connection" ) ; exit ( 1 ) ; } free ( packet ) ; } 
========== 19 ==========
(1) FILE: ../../server.c LINES:24:7 TOKENS:148:211 DIST:1.7

void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } 
(2) FILE: ../../server.c LINES:169:7 TOKENS:1020:1083 DIST:3.5

int serverFD ; int * clientFDs = ( ( void * ) 0 ) ; char * * handles = ( ( void * ) 0 ) ; int clientNum = 0 ; unsigned int __bswap_32 ( unsigned int __bsx ) { ; } __uint64_t __bswap_64 ( __uint64_t __bsx ) { ; } int main ( int argc , char * argv ) { serverFD = tcpServerSetup ( 0 ) ; process ( ) ; return 0 ; } void addClient ( int fd ) { clientNum ++ ; clientFDs = realloc ( clientFDs , sizeof ( int ) * clientNum ) ; clientFDs [ clientNum - 1 ] = fd ; handles = realloc ( handles , sizeof ( char * ) * clientNum ) ; handles [ clientNum - 1 ] = ( ( void * ) 0 ) ; } void setClientName ( void * packet , int fd ) { int i = 0 ; char * name = ( ( void * ) 0 ) ; getFirstHandle ( packet , & name ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] == fd ) { if ( getFDForName ( name ) != - 1 ) { free ( name ) ; sendPacketFlag ( 3 , clientFDs [ i ] ) ; removeClient ( fd ) ; } else { handles [ i ] = name ; sendPacketFlag ( 2 , clientFDs [ i ] ) ; printf ( "Welcome: %s\n" , handles [ i ] ) ; } return ; } } } int getFDForName ( char * name ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( handles [ i ] != ( ( void * ) 0 ) && strcmp ( name , handles [ i ] ) == 0 ) { return clientFDs [ i ] ; } } return - 1 ; } void removeClient ( int fd ) { int i = 0 ; int * newClientFDs ; char * * newHandles ; int foundFD = 0 ; clientNum -- ; newClientFDs = ( int * ) malloc ( sizeof ( int ) * clientNum ) ; newHandles = ( char * * ) malloc ( sizeof ( char * ) * clientNum ) ; for ( i = 0 ; i <= clientNum ; i ++ ) { if ( clientFDs [ i ] != fd ) { if ( ! foundFD ) { newClientFDs [ i ] = clientFDs [ i ] ; newHandles [ i ] = handles [ i ] ; } else { newClientFDs [ i - 1 ] = clientFDs [ i ] ; newHandles [ i - 1 ] = handles [ i ] ; } } else { foundFD = 1 ; if ( handles [ i ] != ( ( void * ) 0 ) ) { printf ( "Bye %s\n" , handles [ i ] ) ; } free ( handles [ i ] ) ; close ( clientFDs [ i ] ) ; } } free ( handles ) ; free ( clientFDs ) ; handles = newHandles ; clientFDs = newClientFDs ; } int getFDForInput ( ) { ; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( serverFD , & fdvar ) ) { return serverFD ; } else { for ( i = 0 ; i < clientNum ; i ++ ) { if ( FD_ISSET ( clientFDs [ i ] , & fdvar ) ) { return clientFDs [ i ] ; } } } return - 1 ; } void acceptClient ( ) { int clientFD = tcpAccept ( serverFD ) ; addClient ( clientFD ) ; } void process ( ) { int fdToProcess ; while ( 1 ) { fdToProcess = getFDForInput ( ) ; if ( fdToProcess == serverFD ) { acceptClient ( ) ; } else { processPacket ( fdToProcess ) ; } } } void processPacket ( int fd ) { uint8_t * packet = malloc ( 1000 ) ; int numBytes = 0 ; if ( ( numBytes = myRecv ( fd , packet , 1000 , 0 ) ) < 0 ) { perror ( "recv call" ) ; exit ( - 1 ) ; } if ( numBytes == 0 ) { removeClient ( fd ) ; } switch ( ( ) -> flag ) { case 1 : setClientName ( packet , fd ) ; break ; case 8 : sendPacketFlag ( 9 , fd ) ; removeClient ( fd ) ; break ; case 4 : broadCast ( fd , packet ) ; break ; case 5 : forwardMessage ( fd , packet ) ; break ; case 10 : sendPacketHandleAck ( 11 , fd ) ; sendHandles ( fd ) ; break ; default : break ; } free ( packet ) ; } void broadCast ( int senderFD , void * packet ) { int i = 0 ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( clientFDs [ i ] != senderFD ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } } } } void forwardMessage ( int senderFD , void * packet ) { int i = 0 ; char * dest = ( ( void * ) 0 ) ; int sent = 0 ; getDestHandle ( packet , & dest ) ; for ( i = 0 ; i < clientNum ; i ++ ) { if ( strcmp ( dest , handles [ i ] ) == 0 ) { if ( sendPacket ( packet , clientFDs [ i ] ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } sent = 1 ; break ; } } if ( sent == 0 ) { sendPacketFlag ( 7 , senderFD ) ; } free ( dest ) ; } 
========== 20 ==========
(1) FILE: ../../cclient.c LINES:210:9 TOKENS:1233:1285 DIST:2.4

dst = strtok ( ( ( void * ) 0 ) , " \n\t" ) ; if ( dst == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketMssg ( mssg , dst , socketFD ) ; } } didWork = 1 ; 
(2) FILE: ../../cclient.c LINES:197:9 TOKENS:1128:1177 DIST:0.0

{ mssg = strtok ( ( ( void * ) 0 ) , "\n" ) ; if ( mssg == ( ( void * ) 0 ) ) { printf ( "Invalid command\n" ) ; } else { sendPacketBroadCast ( mssg , socketFD ) ; } didWork = 1 ; } 
========== 21 ==========
(1) FILE: ../../cclient.c LINES:104:5 TOKENS:712:769 DIST:2.8

; int maxFD = socketFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( socketFD , & fdvar ) ; if ( isConnected ) { FD_SET ( fileno ( stdin ) , & fdvar ) ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } if ( FD_ISSET ( socketFD , & fdvar ) ) { return socketFD ; } 
(2) FILE: ../../server.c LINES:93:4 TOKENS:610:666 DIST:0.0

; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } 
========== 22 ==========
(1) FILE: ../../cclient.c LINES:31:7 TOKENS:175:227 DIST:1.4

void sendPacketBroadCast ( char * mssg , int socket ) { char * toSend ; void * packet ; int hLen = strlen ( myHandle ) ; int maxMssgLen = 1000 - hLen - sizeof ( header ) - 1 ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } 
(2) FILE: ../../cclient.c LINES:63:6 TOKENS:408:463 DIST:3.2

void sendPacketMssg ( char * mssg , char * dest , int socket ) { char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } free ( toSend ) ; toSend = malloc ( theRest ) ; memcpy ( toSend , mssg + consumed , theRest ) ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; free ( toSend ) ; } 
========== 23 ==========
(1) FILE: ../../cclient.c LINES:104:4 TOKENS:710:760 DIST:0.0

if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } 
(2) FILE: ../../server.c LINES:95:4 TOKENS:622:672 DIST:0.0

; int i = 0 ; int maxFD = serverFD + 1 ; FD_ZERO ( & fdvar ) ; FD_SET ( serverFD , & fdvar ) ; for ( i = 0 ; i < clientNum ; i ++ ) { FD_SET ( clientFDs [ i ] , & fdvar ) ; } if ( clientNum > 0 ) { maxFD = clientFDs [ clientNum - 1 ] + 1 ; } if ( mySelect ( maxFD , ( ) & fdvar , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) == - 1 ) { perror ( "Error selecting FD to read from" ) ; exit ( 1 ) ; } 
========== 24 ==========
(1) FILE: ../../cclient.c LINES:239:6 TOKENS:1384:1440 DIST:1.7

void printBroadcast ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getFirstHandle ( packet , & sender ) ; getBroadCastMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
(2) FILE: ../../cclient.c LINES:248:6 TOKENS:1452:1508 DIST:1.7

void printMessage ( void * packet ) { char * sender = ( ( void * ) 0 ) ; char * mssg = ( ( void * ) 0 ) ; getSrcHandle ( packet , & sender ) ; getMssg ( packet , & mssg ) ; printf ( "%s: %s\n" , sender , mssg ) ; free ( mssg ) ; free ( sender ) ; } 
========== 25 ==========
(1) FILE: ../../cclient.c LINES:40:6 TOKENS:253:310 DIST:0.0

while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketBroadcast ( 4 , hLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Broadcast" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } 
(2) FILE: ../../cclient.c LINES:72:6 TOKENS:501:559 DIST:3.6

char * toSend ; void * packet ; int srcLen = strlen ( myHandle ) ; int destLen = strlen ( dest ) ; int maxMssgLen = 1000 - ( srcLen + 1 ) - ( destLen + 1 ) - sizeof ( header ) ; int mssgNum = ( strlen ( mssg ) + 1 ) / maxMssgLen ; int consumed = 0 ; int theRest = ( ( strlen ( mssg ) + 1 ) % maxMssgLen ) + mssgNum ; toSend = malloc ( maxMssgLen ) ; while ( mssgNum > 0 ) { memcpy ( toSend , mssg + consumed , maxMssgLen - 1 ) ; toSend [ maxMssgLen - 1 ] = 0 ; consumed += maxMssgLen - 1 ; packet = makePacketMssg ( 5 , destLen , dest , srcLen , myHandle , toSend ) ; if ( sendPacket ( packet , socket ) < 0 ) { perror ( "Packet Message" ) ; exit ( 1 ) ; } free ( packet ) ; mssgNum -- ; } 
