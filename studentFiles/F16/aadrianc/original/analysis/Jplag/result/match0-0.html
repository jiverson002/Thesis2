<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>server.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>server.c</CENTER></H3><HR>
<PRE>
#include &quot;testing.h&quot;
#include &quot;chatShared.h&quot;
#include &quot;networks.h&quot;
#include &quot;server.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

int serverFD;
int *clientFDs = NULL;
char **handles = NULL;
int clientNum = 0;


int main(int argc, char *argv[]) {
  serverFD = tcpServerSetup(0);
  process();
  return 0;
}

/*
 * Give it a FD and it'll expand the arrays
 */
void addClient(int fd) {
  clientNum++;

  clientFDs = realloc(clientFDs, sizeof(int) * clientNum);
  clientFDs[clientNum-1] = fd;

  handles = realloc(handles, sizeof(char *) * clientNum);
  handles[clientNum-1] = NULL;
}

void setClientName(void *packet, int fd) {
  int i = 0;
  char *name = NULL;
  getFirstHandle(packet, &amp;name);


  for (i = 0; i &lt; clientNum; i++) {
    if(clientFDs[i] == fd) {
      if(getFDForName(name) != -1) {
        free(name);
        sendPacketFlag(CONNECT_ERROR, clientFDs[i]);
        removeClient(fd);
      } else {
        handles[i] = name;
        sendPacketFlag(CONNECT_ACK, clientFDs[i]);
        printf(&quot;Welcome: %s\n&quot;, handles[i]);
      }
      return;
    }
  }
}
/*
  Returns -1 if not found
*/
int getFDForName(char *name) {
  int i = 0;

  for (i = 0; i &lt; clientNum; i++) {
    if(handles[i] != NULL &amp;&amp; strcmp(name, handles[i]) == 0) {
      return clientFDs[i];
    }
  }
  return -1;
}

/*
 * Give it a fd and it'll remove it from the arrays
 */
void removeClient(int fd) {
  int i = 0;
  int *newClientFDs;
  char **newHandles;
  int foundFD = 0;
  clientNum--;

  newClientFDs = (int *)malloc(sizeof(int) * clientNum);
  newHandles = (char **)malloc(sizeof(char *) * clientNum);

  for(i = 0; i &lt;= clientNum; i++) {
    if(clientFDs[i] != fd) {
      if(!foundFD) {
        newClientFDs[i] = clientFDs[i];
        newHandles[i] = handles[i];
      } else {
        newClientFDs[i - 1] = clientFDs[i];
        newHandles[i - 1] = handles[i];
      }
    } else {
      foundFD = 1;
      if(handles[i] != NULL) {
        printf(&quot;Bye %s\n&quot;, handles[i]);
      }
      free(handles[i]);
      close(clientFDs[i]);
    }
  }

  free(handles);
  free(clientFDs);
  handles = newHandles;
  clientFDs = newClientFDs;

}

int getFDForInput() {
  fd_set fdvar;
  int i = 0;
  int maxFD = serverFD + 1;

  FD_ZERO(&amp;fdvar);
  FD_SET(serverFD,&amp;fdvar);
  for(i = 0; i &lt; clientNum; i++) {
      FD_SET(clientFDs[i],&amp;fdvar);
  }

  if (clientNum &gt; 0) {
    maxFD = clientFDs[clientNum-1] + 1;
  }

  if(select(maxFD,(fd_set *) &amp;fdvar, NULL, NULL, NULL) == -1) {
    perror(&quot;Error selecting FD to read from&quot;);
    exit(1);
  }

  if(FD_ISSET(serverFD, &amp;fdvar)) {
    return serverFD;
  } else {
    for(i = 0; i &lt; clientNum; i++) {
        if(FD_ISSET(clientFDs[i], &amp;fdvar)) {
          return clientFDs[i];
        }
    }
  }
  return -1;
}

<A NAME="0"></A>void acceptClient() {
  int clientFD = tcpAccept(serverFD);
  addClient(clientFD);
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match0-1.html#0',3,'match0-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

void process() {
  int fdToProcess;
  while(1) {
    fdToProcess = getFDForInput();
    if(fdToProcess == serverFD) {
      acceptClient();
    } else {
      processPacket(fdToProcess);
    }
  }
}

void processPacket(int fd) {</B></FONT>
  uint8_t *packet = malloc(MAXBUF);
  int numBytes = 0;
  if ((numBytes = recv(fd, packet, MAXBUF, 0)) &lt; 0)
	{
		perror(&quot;recv call&quot;);
		exit(-1);
	}
  if(numBytes == 0) {
<A NAME="1"></A>    removeClient(fd);
  }
  switch(((header *) packet)-&gt;flag) {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match0-1.html#1',3,'match0-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    case CLIENT_CONNECT:
      setClientName(packet, fd);
      break;
    case CLIENT_EXIT:
      sendPacketFlag(EXIT_ACK, fd);
      removeClient(fd);
      break;
    case CLIENT_BROADCAST:
      broadCast(fd, packet);
      break;
    case CLIENT_MESSAGE:
      forwardMessage(fd, packet);
      break;
    case CLIENT_HANDLES:
      sendPacketHandleAck(HANDLES_ACK, fd);
      sendHandles(fd);
      break;
    default:
      break;
  }</B></FONT>
  free(packet);
}

void broadCast (int senderFD, void *packet) {
  int i = 0;
  for(i = 0; i &lt; clientNum; i++) {
    if(clientFDs[i] != senderFD) {
      if(sendPacket(packet, clientFDs[i]) &lt; 0) {
        perror(&quot;Packet Broadcast&quot;);
        exit(1);
      }
    }
  }
}

void forwardMessage (int senderFD, void *packet) {
  int i = 0;
  char *dest = NULL;
  int sent = 0;
  getDestHandle(packet, &amp;dest);

  for(i = 0; i &lt; clientNum; i++) {
    if(strcmp(dest, handles[i]) == 0) {
      if(sendPacket(packet, clientFDs[i]) &lt; 0) {
        perror(&quot;Packet Broadcast&quot;);
        exit(1);
      }
      sent = 1;
      break;
    }
  }
  if(sent == 0) {
    sendPacketFlag(MESSAGE_ERROR, senderFD);
  }
  free(dest);
}

void sendPacketHandleAck(uint8_t flag, int socket) {
  packetHandleAck head;
  headerSetLen((header *)&amp;head, (uint16_t)(sizeof(packetHandleAck) - sizeof(header)));
  packetHandleAckSetNum(&amp;head, clientNum);
  head.head.flag = flag;
  if(send(socket, &amp;head, sizeof(packetHandleAck), 0) &lt; 0) {
    perror(&quot;Flag Packet Send&quot;);
    exit(1);
  }
}

void sendPacketHandle(int socket, char *handle) {
  int hLen = strlen(handle);
  void *packet = makePacketHandle(SERVER_HANDLE, hLen, handle);
  if(sendPacket(packet, socket) &lt; 0) {
    perror(&quot;Packet Connection&quot;);
    exit(1);
  }
  free(packet);
}

void sendHandles(int socket) {
  int i = 0;
  for(i = 0; i &lt; clientNum; i++) {
    sendPacketHandle(socket, handles[i]);
  }
}
</PRE>
</BODY>
</HTML>
