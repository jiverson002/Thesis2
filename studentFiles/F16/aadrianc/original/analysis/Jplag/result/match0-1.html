<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>cclient.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>cclient.c</CENTER></H3><HR>
<PRE>
#include &quot;testing.h&quot;
#include &quot;chatShared.h&quot;
#include &quot;networks.h&quot;
#include &quot;cclient.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;

int socketFD = 0;
int isConnected = 0;
char *myHandle = NULL;

int main(int argc, char * argv[]) {

  if (argc != 4) {
		printf(&quot;usage: %s handle host-name port-number \n&quot;, argv[0]);
		exit(1);
	}

  socketFD = tcpClientSetup(argv[2], argv[3]);
  myHandle = argv[1];
  sendPacketConnection(socketFD);
  process();
  return 0;
}

void sendPacketConnection(int socket) {
  int hLen = strlen(myHandle);
  void *packet = makePacketHandle(CLIENT_CONNECT, hLen, myHandle);
  if(sendPacket(packet, socket) &lt; 0) {
    perror(&quot;Packet Connection&quot;);
    exit(1);
  }
  free(packet);
}

void sendPacketBroadCast(char *mssg, int socket) {
  char *toSend;
  void *packet;
  int hLen = strlen(myHandle);
  int maxMssgLen = MAXBUF - hLen - sizeof(header) - 1;
  /* plus one to account for null */
  int mssgNum = (strlen(mssg) + 1) / maxMssgLen;
  int consumed = 0;
  /* add mssgNum because that's how many nulls we'll end up with
     which we need to account for in the packet*/
  int theRest = ((strlen(mssg) + 1) % maxMssgLen) + mssgNum;

  toSend = malloc(maxMssgLen);
  while(mssgNum &gt; 0) {
    memcpy(toSend, mssg + consumed, maxMssgLen - 1);
    toSend[maxMssgLen - 1] = 0;
    consumed += maxMssgLen - 1;
    packet = makePacketBroadcast(CLIENT_BROADCAST, hLen, myHandle, toSend);
    if(sendPacket(packet, socket) &lt; 0) {
      perror(&quot;Packet Broadcast&quot;);
      exit(1);
    }
    free(packet);
    mssgNum--;
  }
  free(toSend);
  toSend = malloc(theRest);
  memcpy(toSend, mssg + consumed, theRest);
  packet = makePacketBroadcast(CLIENT_BROADCAST, hLen, myHandle, toSend);
  if(sendPacket(packet, socket) &lt; 0) {
    perror(&quot;Packet Broadcast&quot;);
    exit(1);
  }
  free(packet);
  free(toSend);

}

void sendPacketMssg(char *mssg, char *dest, int socket) {
  char *toSend;
  void *packet;
  int srcLen = strlen(myHandle);
  int destLen = strlen(dest);
  int maxMssgLen = MAXBUF - (srcLen + 1) - (destLen + 1) - sizeof(header);
  /* plus one to account for null */
  int mssgNum = (strlen(mssg) + 1) / maxMssgLen;
  int consumed = 0;
  /* add mssgNum because that's how many nulls we'll end up with
     which we need to account for in the packet*/
  int theRest = ((strlen(mssg) + 1) % maxMssgLen) + mssgNum;

  toSend = malloc(maxMssgLen);
  while(mssgNum &gt; 0) {
    memcpy(toSend, mssg + consumed, maxMssgLen - 1);
    toSend[maxMssgLen - 1] = 0;
    consumed += maxMssgLen - 1;
    packet = makePacketMssg(CLIENT_MESSAGE, destLen, dest,
    							 srcLen, myHandle, toSend);
    if(sendPacket(packet, socket) &lt; 0) {
      perror(&quot;Packet Message&quot;);
      exit(1);
    }
    free(packet);
    mssgNum--;
  }
  free(toSend);
  toSend = malloc(theRest);
  memcpy(toSend, mssg + consumed, theRest);
  packet = makePacketMssg(CLIENT_MESSAGE, destLen, dest,
                 srcLen, myHandle, toSend);
  if(sendPacket(packet, socket) &lt; 0) {
    perror(&quot;Packet Message&quot;);
    exit(1);
  }
  free(packet);
  free(toSend);

}


int getFDForInput() {
  fd_set fdvar;
  int maxFD = socketFD + 1;

  FD_ZERO(&amp;fdvar);
  FD_SET(socketFD,&amp;fdvar);
  if(isConnected) {
    FD_SET(fileno(stdin),&amp;fdvar);
  }

  if(select(maxFD,(fd_set *) &amp;fdvar, NULL, NULL, NULL) == -1) {
    perror(&quot;Error selecting FD to read from&quot;);
    exit(1);
  }

  if(FD_ISSET(socketFD, &amp;fdvar)) {
    return socketFD;
  }
  if(isConnected &amp;&amp; FD_ISSET(fileno(stdin), &amp;fdvar)) {
<A NAME="0"></A>    return fileno(stdin);
  }
  return -1;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#0',2,'match0-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

void process() {
  int fdToProcess;
  while(1) {
    printf(&quot;$: &quot;);
    fflush(stdout);
    fdToProcess = getFDForInput();
    if(fdToProcess == fileno(stdin)) {
      processInput();
    } else {
      printf(&quot;\n&quot;);
      processPacket();
    }
  }
}

void processPacket() {</B></FONT>
  uint8_t *packet = malloc(MAXBUF);
  uint8_t *toFree = packet;
  int numBytes = 0;
  if ((numBytes = recv(socketFD, packet, MAXBUF, 0)) &lt; 0)
	{
		perror(&quot;recv call&quot;);
		exit(-1);
	}
  if(numBytes == 0) {
    printf(&quot;Server terminated\n&quot;);
    close(socketFD);
    exit(1);
  }
  while(numBytes &gt; 0) {
    switch(((header *) packet)-&gt;flag) {
      case CONNECT_ACK:
        printf(&quot;Connected to server\n&quot;);
        isConnected = 1;
        break;
      case CONNECT_ERROR:
        printf(&quot;Handle already in use: %s\n&quot;, myHandle);
        exit(1);
        break;
      case EXIT_ACK:
<A NAME="1"></A>        printf(&quot;Goodbye!\n&quot;);
        exit(0);
        break;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#1',2,'match0-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>      case CLIENT_BROADCAST:
        printBroadcast(packet);
        break;
      case MESSAGE_ERROR:
        printf(&quot;No such handle connected to the server\n&quot;);
        break;
      case CLIENT_MESSAGE:
        printMessage(packet);
        break;
      case SERVER_HANDLE:
        printHandle(packet);
        break;
      case HANDLES_ACK:
        printf(&quot;Number of clients: %u\n&quot;, packetHandleAckGetNum((packetHandleAck *)packet));
        //processHandles(packetHandleAckGetNum((packetHandleAck *)packet));
        break;
      default:
        printf(&quot;unknown packet %d with size %d\n&quot;, ((header *) packet)-&gt;flag,numBytes);
        break;
    }</B></FONT>
    packet += headerGetLen((header *) packet) + sizeof(header);
    numBytes -= headerGetLen((header *) packet) + sizeof(header);
  }
  free(toFree);
}

void processInput() {
  int didWork = 0;
  unsigned long inputNum = -1;
  char *line = NULL;
  char *lineToFree = NULL;
  char *cmd = NULL;
  char *mssg = NULL;
  char *dst = NULL;

  getline(&amp;line, (size_t *)&amp;inputNum, stdin);
  lineToFree = line;
  cmd = strtok(line, &quot; \n\t&quot;);

  if (cmd != NULL){
    if(strcmp(cmd, &quot;%E&quot;) == 0 || strcmp(cmd, &quot;%e&quot;) == 0) {
      sendPacketFlag(CLIENT_EXIT, socketFD);
      didWork = 1;
    }
    if(strcmp(cmd, &quot;%B&quot;) == 0 || strcmp(cmd, &quot;%b&quot;) == 0) {
      mssg = strtok(NULL, &quot;\n&quot;);
      if(mssg == NULL) {
        printf(&quot;Invalid command\n&quot;);
      } else {
        sendPacketBroadCast(mssg, socketFD);
      }
      didWork = 1;
    }
    if(strcmp(cmd, &quot;%M&quot;) == 0 || strcmp(cmd, &quot;%m&quot;) == 0) {
      dst = strtok(NULL, &quot; \n\t&quot;);
      if(dst == NULL) {
        printf(&quot;Invalid command\n&quot;);
      } else {
        mssg = strtok(NULL, &quot;\n&quot;);
        if(mssg == NULL) {
          printf(&quot;Invalid command\n&quot;);
        } else {
          sendPacketMssg(mssg, dst, socketFD);
        }
      }
      didWork = 1;
    }
    if(strcmp(cmd, &quot;%L&quot;) == 0 || strcmp(cmd, &quot;%l&quot;) == 0) {
      sendPacketFlag(CLIENT_HANDLES, socketFD);
      didWork = 1;
    }
  }


  free(lineToFree);
  if(didWork == 0) {
    printf(&quot;Invalid command\n&quot;);
  }
}

void processHandles(int handleNum) {
  int i = 0;
  /*stop the client from reading stdin */
  isConnected = 0;
  for(i = 0; i &lt; handleNum; i++) {
    getFDForInput();
    processPacket();
  }
  isConnected = 1;
}

void printBroadcast(void *packet) {
  char *sender = NULL;
  char *mssg = NULL;
  getFirstHandle(packet, &amp;sender);
  getBroadCastMssg(packet, &amp;mssg);
  printf(&quot;%s: %s\n&quot;, sender, mssg);
  free(mssg);
  free(sender);
}

void printMessage(void *packet) {
  char *sender = NULL;
  char *mssg = NULL;
  getSrcHandle(packet, &amp;sender);
  getMssg(packet, &amp;mssg);
  printf(&quot;%s: %s\n&quot;, sender, mssg);
  free(mssg);
  free(sender);
}

void printHandle(void *packet) {
  char *handle = NULL;
  getFirstHandle(packet, &amp;handle);
  printf(&quot;  -%s\n&quot;, handle);
  free(handle);
}
</PRE>
</BODY>
</HTML>
