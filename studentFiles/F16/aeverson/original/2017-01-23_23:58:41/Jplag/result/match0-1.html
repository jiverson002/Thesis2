<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>cclient.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>cclient.c</CENTER></H3><HR>
<PRE>
/******************************************************************************
* tcp_client.c
*
*****************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/uio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;strings.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;ctype.h&gt;

#include &quot;networks.h&quot;
#include &quot;chat.h&quot;

#define INVALID_CMD 'I'
#define CMD_SIZE 3
#define CMD_NDX 1

#define CONSOLE 0

char BUFFER[MAXBUF];

void sendInitPacket(cclient *clientInfo, int socket_num) {
	initPacket sendInfo;
	unsigned char *data = malloc(INIT_SIZE_CONST + clientInfo-&gt;len);

	sendInfo.head.flag = INIT_HANDLE;
	sendInfo.head.packetLen = htons(INIT_SIZE_CONST + clientInfo-&gt;len);
	sendInfo.handle = clientInfo;

	memcpy(data, &amp;sendInfo.head, HEAD_SIZE_CONST);
<A NAME="0"></A>	memcpy(&amp;data[HEAD_SIZE_CONST], &amp;clientInfo-&gt;len, 1);
	memcpy(&amp;data[INIT_SIZE_CONST], clientInfo-&gt;name, clientInfo-&gt;len);

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#0',2,'match0-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	if(send(socket_num, data, INIT_SIZE_CONST + clientInfo-&gt;len, 0) &lt; 0) {
		perror(&quot;Send on Client&quot;);
		exit(FAIL);
	} 

	free(data);
}
	
void sendMessage(cclient *src, cclient *dest, msgData *msg, int socket) {
	messagePacket *msgPck = malloc(sizeof(messagePacket));
	int size = MSG_SIZE_CONST + src-&gt;len + dest-&gt;len + msg-&gt;size;
	unsigned char *data = malloc(size);</B></FONT>
	int index = HEAD_SIZE_CONST;

	msgPck-&gt;head.packetLen = htons(size);
	msgPck-&gt;head.flag = MESSAGE;
	msgPck-&gt;dest = dest;
	msgPck-&gt;src = src;
	msgPck-&gt;text = msg;

	memcpy(data, &amp;msgPck-&gt;head, HEAD_SIZE_CONST);
	memcpy(&amp;data[HEAD_SIZE_CONST], &amp;msgPck-&gt;dest-&gt;len, 1);
	index += 1;
	memcpy(&amp;data[index], msgPck-&gt;dest-&gt;name, msgPck-&gt;dest-&gt;len);
	index += msgPck-&gt;dest-&gt;len;
	memcpy(&amp;data[index], &amp;msgPck-&gt;src-&gt;len, 1);
	index += 1;
	memcpy(&amp;data[index], msgPck-&gt;src-&gt;name, msgPck-&gt;src-&gt;len);
	index += msgPck-&gt;src-&gt;len;
	memcpy(&amp;data[index], msgPck-&gt;text-&gt;msg, msgPck-&gt;text-&gt;size);
	
	if(send(socket, (void*)data, size, 0) &lt; 0) {
		perror(&quot;Send Message&quot;);
		exit(FAIL);
	}

	free(msgPck);
	free(data);
}

void sendMsgToAll(cclient *myInfo, msgData *textMsg, int socketNum) {
	chatHead head;
	int length = BCAST_SIZE_CONST + myInfo-&gt;len + textMsg-&gt;size;
	char *data = malloc(length);

	head.packetLen = htons(length);
	head.flag = BROADCAST;

	memcpy(data, &amp;head, HEAD_SIZE_CONST);
	memcpy(&amp;data[BCAST_SRC_LEN_OFF], &amp;myInfo-&gt;len, 1);
	memcpy(&amp;data[BCAST_SRC_OFF], myInfo-&gt;name, myInfo-&gt;len);
	memcpy(&amp;data[BCAST_SRC_OFF + myInfo-&gt;len], textMsg-&gt;msg, strlen(textMsg-&gt;msg));

	if(send(socketNum, (void*)data, length, 0) &lt; 0) {
		perror(&quot;Send broadcast&quot;);
		exit(FAIL);
	}

	free(data);
}

void sendListRequest(cclient *myInfo, int socket) {
	listReq *data = malloc(sizeof(listReq));

	data-&gt;packetLen = htons(HEAD_SIZE_CONST);
	data-&gt;flag = REQ_HANDLES;

	if(send(socket, (void*)data, HEAD_SIZE_CONST, 0) &lt; 0) {
		perror(&quot;Send List Req&quot;);
		exit(FAIL);
	}
	free(data);
}

void sendExitRequest(cclient *myInfo, int socket) { 
	exitReq *data = malloc(sizeof(exitReq));

	data-&gt;packetLen = htons(HEAD_SIZE_CONST);
	data-&gt;flag = EXIT_REQ;

	if(send(socket, (void*)data, HEAD_SIZE_CONST, 0) &lt; 0) {
		perror(&quot;Send Exit Req&quot;);
		exit(FAIL);
	}
	free(data);
}


int getHandle(cclient *handleInfo, char *buff) {
	handleInfo-&gt;len = strcspn(buff, &quot; \n&quot;);
	
	if(handleInfo-&gt;len == 0) {
		return FAIL;
	}
	handleInfo-&gt;name = malloc(handleInfo-&gt;len);
	memcpy(handleInfo-&gt;name, buff, handleInfo-&gt;len);
	
	return PASS;
}
	
void getText(msgData *textMsg, char *buff) {
	textMsg-&gt;size = strcspn(buff, &quot;\n&quot;);

	if(textMsg-&gt;size &gt; MAX_MSG) {
		textMsg-&gt;msg = malloc(MAX_MSG);
		memcpy(textMsg-&gt;msg, buff, MAX_MSG - 1);
		textMsg-&gt;msg[MAX_MSG] = '\0';

		textMsg-&gt;remaining = malloc(textMsg-&gt;size - (MAX_MSG - 1));
		memcpy(textMsg-&gt;remaining, &amp;buff[MAX_MSG], textMsg-&gt;size - (MAX_MSG - 1));
		
	}
	else {
		textMsg-&gt;msg = malloc(textMsg-&gt;size + 1);
		memcpy(textMsg-&gt;msg, buff, textMsg-&gt;size);
		textMsg-&gt;msg[textMsg-&gt;size] = '\0';
	}
}


void processCommands(cclient *myInfo, int socketNum) {
   char option, buff[MAXBUF];
	char *data;
	uint32_t cmdSize;
	cclient destInfo;
	msgData textMsg;
	
	/* Get user input, parse and determine if cmd valid.*/
	fgets(buff, MAXBUF, stdin);
	cmdSize = strcspn(buff, &quot; \n&quot;) + 1;

	data = &amp;buff[cmdSize];
	if(cmdSize == CMD_SIZE &amp;&amp; buff[0] == '%')
		option = toupper(buff[CMD_NDX]);
	else
		option = INVALID_CMD;	

	switch(option) {
		case 'M':
			
			/* Parse dest handle &amp; copy over to struct. */
			if(getHandle(&amp;destInfo, data) &lt; 0) {
				fprintf(stderr, &quot;Invalid command.\n&quot;);
				break;
			}

			/* Advance buffer and get message data. */
			data += destInfo.len + 1;
			getText(&amp;textMsg, data);

			sendMessage(myInfo, &amp;destInfo, &amp;textMsg, socketNum);

			free(destInfo.name);
			free(textMsg.msg);

			break;

		case 'B':
			/* Get message data. */
			getText(&amp;textMsg, data);
			
			/* Send message data to all clients! */
			sendMsgToAll(myInfo, &amp;textMsg, socketNum);

			free(textMsg.msg);
			break;
			
		case 'L':
			sendListRequest(myInfo, socketNum);
			break;

		case 'E':
			sendExitRequest(myInfo, socketNum);			
		break;
		
		default:
			fprintf(stderr,&quot;Invalid command.\n&quot;);
		break;
	}
	fprintf(stderr,&quot;$:&quot;);

}
void getPacketHandle(cclient *dest, int offset) {
	memcpy(&amp;dest-&gt;len, &amp;BUFFER[offset], 1);
	dest-&gt;name = malloc(dest-&gt;len + 1);
	memcpy(dest-&gt;name, &amp;BUFFER[offset + 1], dest-&gt;len);
	dest-&gt;name[dest-&gt;len] = '\0';
}
	
void getPacketText(msgData *msg, int index, int packetLen) {
	int length = packetLen - index;

	msg-&gt;msg = malloc(length);
	strcpy(msg-&gt;msg, &amp;BUFFER[index]);
}

void parseDetails(int numBytes, int socket, int destSocket, cclient *myInfo) {
	int32_t numHandles;
	uint16_t length;
	uint8_t flag;
	cclient dest;
	cclient src;
	msgData msg;
	
	/* Get the length &amp; the flag of the packet */
	memcpy(&amp;length, BUFFER, 2);
	length = ntohs(length);
	memcpy(&amp;flag, &amp;BUFFER[FLAG_OFF], 1);
	
	switch(flag) {
		case ACK_HANDLE: 
			/* Don't need to do anything. Just proceed.*/	
		break;

		case BAD_HANDLE:
			fprintf(stderr,&quot;\nHandle already in use: %s\n&quot;, myInfo-&gt;name);
			close(socket);
			exit(PASS);
		break;
		
		case MESSAGE:
			getPacketHandle(&amp;dest, MSG_DEST_LEN_OFF);
			getPacketHandle(&amp;src, MSG_SRC_LEN_OFF + dest.len);
			getPacketText(&amp;msg, MSG_TEXT_LEN_OFF + dest.len + src.len, length);
					
			fprintf(stderr, &quot;\n%s: %s\n&quot;, src.name, msg.msg);
			fprintf(stderr, &quot;$:&quot;);

			free(dest.name);
			free(src.name);
			free(msg.msg);
		break;

		case BAD_DEST:
			getPacketHandle(&amp;dest, BAD_DEST_LEN_OFF);
			fprintf(stderr,&quot;\nClient with handle %s does not exist.\n&quot;, dest.name);
			fprintf(stderr,&quot;$:&quot;);
			free(dest.name);
		break;
	
		case ACK_EXIT:
			close(socket);
			exit(PASS);
		break;

		case NUM_HANDLES:
			memcpy(&amp;numHandles, &amp;BUFFER[HEAD_SIZE_CONST], 4);
			numHandles = ntohl(numHandles);
			printf(&quot;Number of clients: %d\n&quot;, numHandles);
			int received = 0;

			while(received != numHandles) {
				int nbytes = recv(socket, BUFFER, MAXBUF, 0);
				if(nbytes &lt; 0) {
					perror(&quot;read&quot;);
					exit(FAIL);
				}
				else if(nbytes == 0) {
					fprintf(stderr, &quot;\nServer Terminated.\n&quot;);
					exit(PASS);
				}
				else {
					getPacketHandle(&amp;dest, REQ_HANDLE_LEN_OFF);
					printf(&quot;\t%s\n&quot;,dest.name);
					received++;
					free(dest.name);
				}									
			}
		break;

		case GIVE_HANDLE:
		break;

		default:
			fprintf(stderr,&quot;\nBad flag!\n&quot;);
			fprintf(stderr,&quot;$:&quot;);
		break;	
	}
}

void startChat(cclient *myInfo, int socketNum) {
	fd_set useFds, saveFds;
	int ndx;

	FD_ZERO(&amp;saveFds);
<A NAME="1"></A>	FD_SET(CONSOLE, &amp;saveFds);	  // STDIN
	FD_SET(socketNum, &amp;saveFds); // SERVER

<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#1',2,'match0-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	while(1) {
		useFds = saveFds;
		if(select(FD_SETSIZE, &amp;useFds, NULL, NULL, NULL) &lt; 0) {
			perror(&quot;select&quot;);
			exit(FAIL);
		}	

		for(ndx = 0; ndx &lt; FD_SETSIZE; ndx++) {
			if(FD_ISSET(ndx, &amp;useFds)) {
<A NAME="2"></A>			
				/* Data coming in from server. */
				if(ndx == socketNum) {</B></FONT>
<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#2',2,'match0-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>					int nbytes = read(ndx, BUFFER, MAXBUF);
					if(nbytes &lt; 0) {
						perror(&quot;read&quot;);
						exit(FAIL);
					}	
					/* Server closed. */
					else if(nbytes == 0) {
						FD_CLR(ndx, &amp;saveFds);
						fprintf(stderr, &quot;\nServer Terminated.\n&quot;);
						exit(PASS);
					}
					else {
						parseDetails(nbytes, socketNum, ndx, myInfo);
					}
				}</B></FONT>
				/* Data coming in from stdin. */
				else if(ndx == CONSOLE) {
					processCommands(myInfo,socketNum);					
				}
			}
		}
	}
}

int main(int argc, char * argv[]) {
	int socketNum = 0;      //socket descriptor
	cclient *myInfo = malloc(sizeof(cclient));

	/* check command line arguments  */
	if (argc != 4) {
		printf(&quot;usage: %s handle server-name server-port\n&quot;, argv[0]);
		exit(1);
	}

	/* Capture the client's name. */
	myInfo-&gt;len = strlen(argv[1]);
	myInfo-&gt;name = malloc(myInfo-&gt;len);
	memcpy(myInfo-&gt;name, argv[1], myInfo-&gt;len);

	/* set up the TCP Client socket  */
	socketNum = tcpClientSetup(argv[2], argv[3]);

	/* Need to create init_packet and send data to server. */
	sendInitPacket(myInfo, socketNum);

	fprintf(stderr,&quot;$:&quot;);
	
	/* Start communicating with the server, other clients and console. */
	startChat(myInfo, socketNum);

	close(socketNum);
	free(myInfo);

	return 0;
}


</PRE>
</BODY>
</HTML>
