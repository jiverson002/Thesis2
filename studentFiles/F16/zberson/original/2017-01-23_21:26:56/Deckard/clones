========== 1 ==========
(1) FILE: ../../cclient.c LINES:86:13 TOKENS:344:405 DIST:0.0

static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
(2) FILE: ../../cclient.c LINES:100:13 TOKENS:406:467 DIST:0.0

static void request_list ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG10 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
========== 2 ==========
(1) FILE: ../../packets.c LINES:135:7 TOKENS:706:760 DIST:2.4

case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : raw -> src_handle_len = * ( pos ++ ) ; raw -> src_handle_name = calloc ( raw -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> src_handle_name , pos , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; 
(2) FILE: ../../packets.c LINES:128:6 TOKENS:647:701 DIST:2.8

switch ( raw -> type ) { case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : raw -> src_handle_len = * ( pos ++ ) ; raw -> src_handle_name = calloc ( raw -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> src_handle_name , pos , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; break ; default : break ; } 
========== 3 ==========
(1) FILE: ../../cclient.c LINES:102:13 TOKENS:420:470 DIST:2.2

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static void request_list ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG10 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static BOOLEAN get_message ( char * buf ) { ; buf [ i ++ ] = fgetc ( stdin ) ; while ( '\n' != buf [ i - 1 ] && i < MAX_INPUT_SIZE ) { buf [ i ++ ] = fgetc ( stdin ) ; } if ( '\n' == buf [ i - 1 ] ) { i -- ; result = FALSE ; } buf [ i ] = '\0' ; return result ; } 
(2) FILE: ../../cclient.c LINES:88:13 TOKENS:358:410 DIST:0.0

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static void request_list ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG10 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
========== 4 ==========
(1) FILE: ../../server.c LINES:98:10 TOKENS:358:419 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; 
(2) FILE: ../../server.c LINES:116:8 TOKENS:467:528 DIST:3.7

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; 
========== 5 ==========
(1) FILE: ../../cclient.c LINES:326:11 TOKENS:1535:1585 DIST:0.0

case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , name ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , raw -> src_handle_name ) ; printf ( "%s\n" , raw -> message ) ; 
(2) FILE: ../../cclient.c LINES:334:11 TOKENS:1567:1618 DIST:2.4

case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , name ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , raw -> src_handle_name ) ; printf ( "%s\n" , raw -> message ) ; fflush ( stdout ) ; break ; case FLAG7 : printf ( "\nClient with handle %s does not exist.\n" , raw -> src_handle_name ) ; fflush ( stdout ) ; break ; case FLAG9 : exit_prog ( ) ; 
========== 6 ==========
(1) FILE: ../../packets.c LINES:135:7 TOKENS:706:760 DIST:3.5

case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : raw -> src_handle_len = * ( pos ++ ) ; raw -> src_handle_name = calloc ( raw -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> src_handle_name , pos , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; 
(2) FILE: ../../packets.c LINES:127:6 TOKENS:639:695 DIST:0.0

uint8_t * pos ; uint16_t message_len ; pos = rdy + OFFSET_FLAG ; raw -> type = * ( pos ) ; if ( raw -> type < FLAG1 || raw -> type == NULL6 || raw -> type > FLAG12 ) { fprintf ( stderr , "Invalid flag type '%u'\n" , raw -> type ) ; return - 1 ; } if ( raw -> type == FLAG12 ) { pos = rdy + OFFSET_HANDLE_LEN ; raw -> packet_len = * ( pos ) + OFFSET_HANDLE_NAME ; } else { pos = rdy + OFFSET_PACKET_LEN ; raw -> packet_len = ntohs ( * ( ( uint16_t * ) pos ) ) ; } pos = rdy + OFFSET_HANDLE_LEN ; switch ( raw -> type ) { case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : raw -> src_handle_len = * ( pos ++ ) ; raw -> src_handle_name = calloc ( raw -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> src_handle_name , pos , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; break ; default : break ; } 
========== 7 ==========
(1) FILE: ../../cclient.c LINES:91:12 TOKENS:373:428 DIST:3.3

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static void request_list ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG10 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
(2) FILE: ../../cclient.c LINES:293:12 TOKENS:1358:1412 DIST:2.8

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static void request_list ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG10 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static BOOLEAN get_message ( char * buf ) { ; buf [ i ++ ] = fgetc ( stdin ) ; while ( '\n' != buf [ i - 1 ] && i < MAX_INPUT_SIZE ) { buf [ i ++ ] = fgetc ( stdin ) ; } if ( '\n' == buf [ i - 1 ] ) { i -- ; result = FALSE ; } buf [ i ] = '\0' ; return result ; } static void send_message ( ) { ; while ( cont ) { raw -> message = calloc ( MAX_INPUT_SIZE + 1 , sizeof ( char ) ) ; if ( ! isEmpty ) { cont = get_message ( raw -> message ) ; } if ( dest_name ) { raw -> type = FLAG5 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) + 1 + strlen ( name ) + strlen ( raw -> message ) ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; strcpy ( raw -> dest_handle_name , dest_name ) ; } else { raw -> type = FLAG4 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) + strlen ( raw -> message ) ; } raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; strcpy ( raw -> src_handle_name , name ) ; rdy = create_rdy_packet ( raw -> packet_len ) ; construct_packet ( rdy , raw ) ; write ( sock , rdy , raw -> packet_len ) ; raw = recycle_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; rdy = NULL ; } destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static void wait_for_input ( ) { char tmp = '\0' ; while ( '\n' != tmp ) { tmp = fgetc ( stdin ) ; } } static void prompt ( ) { char input [ IN_BUF ] = { 0 } ; char cmd = '\0' ; int chars_read = 0 ; input [ chars_read ++ ] = fgetc ( stdin ) ; if ( '%' != input [ 0 ] ) { cmd = '\0' ; if ( '\n' != input [ 0 ] ) { wait_for_input ( ) ; } } else { input [ chars_read ++ ] = fgetc ( stdin ) ; if ( '\n' != input [ 1 ] ) { cmd = input [ 1 ] ; input [ chars_read ++ ] = fgetc ( stdin ) ; } } switch ( cmd ) { case 'm' : case 'M' : if ( input [ 2 ] != ' ' ) { if ( input [ 2 ] != '\n' ) { wait_for_input ( ) ; } print_commands ( ) ; break ; } memset ( input , '\0' , 3 ) ; chars_read = 0 ; input [ chars_read ] = fgetc ( stdin ) ; while ( '\n' != input [ chars_read ] && ' ' != input [ chars_read ] ) { input [ ++ chars_read ] = fgetc ( stdin ) ; } if ( chars_read == 0 && '\n' == input [ chars_read ] ) { print_commands ( ) ; } else { if ( '\n' == input [ chars_read ] ) { input [ chars_read ] = '\0' ; send_message ( input , TRUE ) ; } else { input [ chars_read ] = '\0' ; send_message ( input , FALSE ) ; } } break ; case 'b' : case 'B' : if ( input [ 2 ] == ' ' ) { memset ( input , '\0' , 3 ) ; send_message ( NULL , FALSE ) ; } else if ( input [ 2 ] == '\n' ) { memset ( input , '\0' , 3 ) ; send_message ( NULL , TRUE ) ; } else { print_commands ( ) ; } break ; case 'l' : case 'L' : if ( input [ 2 ] != '\n' ) { wait_for_input ( ) ; print_commands ( ) ; } else { request_list ( ) ; } break ; case 'e' : case 'E' : if ( '\n' != input [ 2 ] ) { wait_for_input ( ) ; print_commands ( ) ; } else { request_exit ( ) ; } break ; default : print_commands ( ) ; break ; } } static void talk ( ) { ; int status = 0 ; printf ( "$: " ) ; fflush ( stdout ) ; fflush ( stdin ) ; while ( TRUE ) { FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; FD_SET ( 0 , & readfd ) ; status = select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; if ( - 1 == status ) { perror ( "select call" ) ; } if ( FD_ISSET ( sock , & readfd ) ) { process ( ) ; } if ( FD_ISSET ( 0 , & readfd ) ) { tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; prompt ( ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; } status = 0 ; printf ( "$: " ) ; fflush ( stdout ) ; fflush ( stdin ) ; } } static void process ( ) { rdy_packet * rdy = create_rdy_packet ( MAX_PACKET_LEN ) ; raw_packet * raw = create_raw_packet ( ) ; int status ; int to_process = 0 ; int i ; int size = 0 ; status = read ( sock , rdy , OFFSET_HANDLE_LEN ) ; if ( ! status ) { exit_prog ( ) ; } if ( * ( rdy + OFFSET_FLAG ) != FLAG12 ) { size = ntohs ( * ( ( uint16_t * ) rdy ) ) - OFFSET_HANDLE_LEN ; } else { status += read ( sock , rdy + OFFSET_HANDLE_LEN , 1 ) ; size = * ( rdy + OFFSET_HANDLE_LEN ) ; } status = read ( sock , rdy + status , size ) ; deconstruct_packet ( raw , rdy ) ; switch ( raw -> type ) { case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , name ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , raw -> src_handle_name ) ; printf ( "%s\n" , raw -> message ) ; fflush ( stdout ) ; break ; case FLAG7 : printf ( "\nClient with handle %s does not exist.\n" , raw -> src_handle_name ) ; fflush ( stdout ) ; break ; case FLAG9 : exit_prog ( ) ; break ; case FLAG11 : to_process = raw -> to_be_sent ; printf ( "\nNumber of clients: %u\n" , to_process ) ; for ( i = 0 ; i < to_process ; i ++ ) { process ( ) ; } fflush ( stdout ) ; break ; case FLAG12 : printf ( "\t%s\n" , raw -> src_handle_name ) ; break ; default : break ; } } 
(3) FILE: ../../cclient.c LINES:79:12 TOKENS:314:372 DIST:0.0

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
========== 8 ==========
(1) FILE: ../../server.c LINES:111:11 TOKENS:448:500 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; 
(2) FILE: ../../server.c LINES:96:11 TOKENS:349:400 DIST:3.7

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; 
========== 9 ==========
(1) FILE: ../../server.c LINES:102:7 TOKENS:375:433 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; 
(2) FILE: ../../server.c LINES:118:7 TOKENS:484:542 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; 
========== 10 ==========
(1) FILE: ../../packets.c LINES:71:10 TOKENS:297:356 DIST:0.0

static void clear_raw_packet ( ) { packet -> type = NULL0 ; packet -> packet_len = 0 ; packet -> src_handle_len = 0 ; packet -> src_handle_name = NULL ; packet -> dest_handle_len = 0 ; packet -> dest_handle_name = NULL ; packet -> message = NULL ; packet -> to_be_sent = 0 ; } raw_packet * create_raw_packet ( ) { raw_packet * raw = calloc ( 1 , sizeof ( raw_packet ) ) ; clear_raw_packet ( raw ) ; return raw ; } rdy_packet * create_rdy_packet ( uint16_t size ) { rdy_packet * rdy = calloc ( size , sizeof ( char ) ) ; return rdy ; } void destroy_raw_packet ( ) { if ( packet -> src_handle_name ) { free ( packet -> src_handle_name ) ; packet -> src_handle_name = NULL ; } if ( packet -> dest_handle_name ) { free ( packet -> dest_handle_name ) ; packet -> dest_handle_name = NULL ; } if ( packet -> message ) { free ( packet -> message ) ; packet -> message = NULL ; } free ( packet ) ; } void destroy_rdy_packet ( ) { if ( packet ) { free ( packet ) ; } } raw_packet * recycle_raw_packet ( ) { destroy_raw_packet ( packet ) ; return create_raw_packet ( ) ; } rdy_packet * recycle_rdy_packet ( ) { destroy_rdy_packet ( packet ) ; return create_rdy_packet ( size ) ; } static void construct_packet_header ( ) { uint8_t * pos ; pos = rdy + OFFSET_PACKET_LEN ; if ( raw -> type == FLAG12 ) { * ( pos ) = 0 ; * ( pos + 1 ) = 0 ; } else { * ( ( uint16_t * ) pos ) = htons ( raw -> packet_len ) ; } pos = rdy + OFFSET_FLAG ; * ( pos ) = raw -> type ; } int construct_packet ( ) { uint8_t * pos ; uint16_t message_len ; if ( raw -> type < FLAG1 || raw -> type == NULL6 || raw -> type > FLAG12 ) { fprintf ( stderr , "Invalid flag type '%u'\n" , raw -> type ) ; return - 1 ; } construct_packet_header ( rdy , raw ) ; pos = rdy + OFFSET_HANDLE_LEN ; if ( raw -> dest_handle_len ) { * ( pos ++ ) = raw -> dest_handle_len ; memcpy ( pos , raw -> dest_handle_name , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; } if ( raw -> src_handle_len ) { * ( pos ++ ) = raw -> src_handle_len ; memcpy ( pos , raw -> src_handle_name , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; } else if ( raw -> to_be_sent ) { * ( ( uint32_t * ) pos ) = htonl ( raw -> to_be_sent ) ; } if ( raw -> type == FLAG4 || raw -> type == FLAG5 ) { message_len = raw -> packet_len - raw -> src_handle_len - raw -> dest_handle_len - raw -> type ; memcpy ( pos , raw -> message , message_len ) ; } return 0 ; } 
(2) FILE: ../../packets.c LINES:105:11 TOKENS:519:581 DIST:2.8

static void clear_raw_packet ( ) { packet -> type = NULL0 ; packet -> packet_len = 0 ; packet -> src_handle_len = 0 ; packet -> src_handle_name = NULL ; packet -> dest_handle_len = 0 ; packet -> dest_handle_name = NULL ; packet -> message = NULL ; packet -> to_be_sent = 0 ; } raw_packet * create_raw_packet ( ) { raw_packet * raw = calloc ( 1 , sizeof ( raw_packet ) ) ; clear_raw_packet ( raw ) ; return raw ; } rdy_packet * create_rdy_packet ( uint16_t size ) { rdy_packet * rdy = calloc ( size , sizeof ( char ) ) ; return rdy ; } void destroy_raw_packet ( ) { if ( packet -> src_handle_name ) { free ( packet -> src_handle_name ) ; packet -> src_handle_name = NULL ; } if ( packet -> dest_handle_name ) { free ( packet -> dest_handle_name ) ; packet -> dest_handle_name = NULL ; } if ( packet -> message ) { free ( packet -> message ) ; packet -> message = NULL ; } free ( packet ) ; } void destroy_rdy_packet ( ) { if ( packet ) { free ( packet ) ; } } raw_packet * recycle_raw_packet ( ) { destroy_raw_packet ( packet ) ; return create_raw_packet ( ) ; } rdy_packet * recycle_rdy_packet ( ) { destroy_rdy_packet ( packet ) ; return create_rdy_packet ( size ) ; } static void construct_packet_header ( ) { uint8_t * pos ; pos = rdy + OFFSET_PACKET_LEN ; if ( raw -> type == FLAG12 ) { * ( pos ) = 0 ; * ( pos + 1 ) = 0 ; } else { * ( ( uint16_t * ) pos ) = htons ( raw -> packet_len ) ; } pos = rdy + OFFSET_FLAG ; * ( pos ) = raw -> type ; } int construct_packet ( ) { uint8_t * pos ; uint16_t message_len ; if ( raw -> type < FLAG1 || raw -> type == NULL6 || raw -> type > FLAG12 ) { fprintf ( stderr , "Invalid flag type '%u'\n" , raw -> type ) ; return - 1 ; } construct_packet_header ( rdy , raw ) ; pos = rdy + OFFSET_HANDLE_LEN ; if ( raw -> dest_handle_len ) { * ( pos ++ ) = raw -> dest_handle_len ; memcpy ( pos , raw -> dest_handle_name , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; } if ( raw -> src_handle_len ) { * ( pos ++ ) = raw -> src_handle_len ; memcpy ( pos , raw -> src_handle_name , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; } else if ( raw -> to_be_sent ) { * ( ( uint32_t * ) pos ) = htonl ( raw -> to_be_sent ) ; } if ( raw -> type == FLAG4 || raw -> type == FLAG5 ) { message_len = raw -> packet_len - raw -> src_handle_len - raw -> dest_handle_len - raw -> type ; memcpy ( pos , raw -> message , message_len ) ; } return 0 ; } int deconstruct_packet ( ) { uint8_t * pos ; uint16_t message_len ; pos = rdy + OFFSET_FLAG ; raw -> type = * ( pos ) ; if ( raw -> type < FLAG1 || raw -> type == NULL6 || raw -> type > FLAG12 ) { fprintf ( stderr , "Invalid flag type '%u'\n" , raw -> type ) ; return - 1 ; } if ( raw -> type == FLAG12 ) { pos = rdy + OFFSET_HANDLE_LEN ; raw -> packet_len = * ( pos ) + OFFSET_HANDLE_NAME ; } else { pos = rdy + OFFSET_PACKET_LEN ; raw -> packet_len = ntohs ( * ( ( uint16_t * ) pos ) ) ; } pos = rdy + OFFSET_HANDLE_LEN ; switch ( raw -> type ) { case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : raw -> src_handle_len = * ( pos ++ ) ; raw -> src_handle_name = calloc ( raw -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> src_handle_name , pos , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; break ; default : break ; } if ( raw -> type == FLAG4 || raw -> type == FLAG5 ) { message_len = raw -> packet_len - raw -> src_handle_len - raw -> dest_handle_len - raw -> type ; raw -> message = calloc ( message_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> message , pos , message_len ) ; } else if ( raw -> type == FLAG11 ) { raw -> to_be_sent = ntohl ( * ( ( uint32_t * ) pos ) ) ; } return 0 ; } 
========== 11 ==========
(1) FILE: ../../cclient.c LINES:81:11 TOKENS:323:378 DIST:0.0

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
(2) FILE: ../../cclient.c LINES:94:12 TOKENS:386:440 DIST:2.4

static char name [ MAX_NAME_SIZE + 1 ] ; static int sock = 0 ; static struct termios old ; static struct termios cur ; static void process ( ) ; static void print_usage ( const char * * argv ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * argv ) ; exit ( - 1 ) ; } static void parse_args ( int argc , const char * * argv ) { if ( argc != 4 ) { print_usage ( argv ) ; } sock = dns_lookup ( * ( argv + CMD_OFFSET_IP ) , * ( argv + CMD_OFFSET_PORT ) ) ; memset ( name , '\0' , MAX_NAME_SIZE + 1 ) ; strcpy ( name , * ( argv + CMD_OFFSET_NAME ) ) ; } static void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } static void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( STDIN_FILENO , TCSANOW , & old ) ; exit ( 0 ) ; } static void request_exit ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG8 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } static void request_list ( ) { raw_packet * raw = create_raw_packet ( ) ; rdy_packet * rdy = create_rdy_packet ( OFFSET_HANDLE_LEN ) ; raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG10 ; construct_packet ( rdy , raw ) ; write ( sock , rdy , OFFSET_HANDLE_LEN ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy ) ; } 
========== 12 ==========
(1) FILE: ../../cclient.c LINES:346:10 TOKENS:1621:1674 DIST:2.6

case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , name ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , raw -> src_handle_name ) ; printf ( "%s\n" , raw -> message ) ; fflush ( stdout ) ; break ; case FLAG7 : printf ( "\nClient with handle %s does not exist.\n" , raw -> src_handle_name ) ; fflush ( stdout ) ; break ; case FLAG9 : exit_prog ( ) ; break ; case FLAG11 : to_process = raw -> to_be_sent ; printf ( "\nNumber of clients: %u\n" , to_process ) ; for ( i = 0 ; i < to_process ; i ++ ) { process ( ) ; } fflush ( stdout ) ; break ; case FLAG12 : printf ( "\t%s\n" , raw -> src_handle_name ) ; 
(2) FILE: ../../cclient.c LINES:339:11 TOKENS:1594:1645 DIST:0.0

case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , name ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , raw -> src_handle_name ) ; printf ( "%s\n" , raw -> message ) ; fflush ( stdout ) ; break ; case FLAG7 : printf ( "\nClient with handle %s does not exist.\n" , raw -> src_handle_name ) ; fflush ( stdout ) ; break ; case FLAG9 : exit_prog ( ) ; break ; case FLAG11 : to_process = raw -> to_be_sent ; printf ( "\nNumber of clients: %u\n" , to_process ) ; for ( i = 0 ; i < to_process ; i ++ ) { process ( ) ; } 
========== 13 ==========
(1) FILE: ../../server.c LINES:106:4 TOKENS:392:444 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
(2) FILE: ../../cclient.c LINES:55:4 TOKENS:162:214 DIST:0.0

; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; 
(3) FILE: ../../server.c LINES:122:4 TOKENS:501:553 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
========== 14 ==========
(1) FILE: ../../connection.c LINES:51:9 TOKENS:164:221 DIST:2.0

int sock = 0 ; int status = 0 ; struct sockaddr_in addr ; socklen_t len = sizeof ( addr ) ; sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( sock < 3 ) { perror ( "server socket call" ) ; exit ( - 2 ) ; } addr . sin_family = AF_INET ; addr . sin_port = htons ( port ) ; addr . sin_addr . s_addr = INADDR_ANY ; status = bind ( sock , ( struct sockaddr * ) & addr , len ) ; if ( status < 0 ) { perror ( "bind call" ) ; exit ( - 3 ) ; } status = listen ( sock , BACKLOG ) ; if ( status < 0 ) { perror ( "listen call" ) ; exit ( - 4 ) ; } status = getsockname ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( status < 0 ) { perror ( "getsockname call" ) ; exit ( - 8 ) ; } 
(2) FILE: ../../connection.c LINES:45:9 TOKENS:128:184 DIST:0.0

int sock = 0 ; int status = 0 ; struct sockaddr_in addr ; socklen_t len = sizeof ( addr ) ; sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( sock < 3 ) { perror ( "server socket call" ) ; exit ( - 2 ) ; } addr . sin_family = AF_INET ; addr . sin_port = htons ( port ) ; addr . sin_addr . s_addr = INADDR_ANY ; status = bind ( sock , ( struct sockaddr * ) & addr , len ) ; if ( status < 0 ) { perror ( "bind call" ) ; exit ( - 3 ) ; } status = listen ( sock , BACKLOG ) ; if ( status < 0 ) { perror ( "listen call" ) ; exit ( - 4 ) ; } 
========== 15 ==========
(1) FILE: ../../cclient.c LINES:152:7 TOKENS:668:720 DIST:3.2

raw -> message = calloc ( MAX_INPUT_SIZE + 1 , sizeof ( char ) ) ; if ( ! isEmpty ) { cont = get_message ( raw -> message ) ; } if ( dest_name ) { raw -> type = FLAG5 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) + 1 + strlen ( name ) + strlen ( raw -> message ) ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; strcpy ( raw -> dest_handle_name , dest_name ) ; } else { raw -> type = FLAG4 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) + strlen ( raw -> message ) ; } raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; 
(2) FILE: ../../server.c LINES:106:4 TOKENS:392:444 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
(3) FILE: ../../cclient.c LINES:55:4 TOKENS:162:214 DIST:0.0

; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; 
(4) FILE: ../../server.c LINES:122:4 TOKENS:501:553 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
========== 16 ==========
(1) FILE: ../../handle.c LINES:69:13 TOKENS:234:290 DIST:3.0

c_handle * cur = * head ; c_handle * last = * head ; if ( sock < 3 ) { return - 1 ; } if ( cur ) { if ( cur -> sock == sock ) { * head = cur -> next ; deleteHandle ( cur ) ; return 0 ; } cur = * head ; } while ( cur ) { if ( cur -> sock == sock ) { last -> next = cur -> next ; deleteHandle ( cur ) ; return 0 ; } last = cur ; cur = cur -> next ; } 
(2) FILE: ../../handle.c LINES:75:15 TOKENS:258:314 DIST:0.0

static void deleteHandle ( ) { free ( han ) ; } void destroy_list ( ) { c_handle * pos = * head ; c_handle * last = pos ; if ( pos ) { while ( pos -> next ) { pos = pos -> next ; deleteHandle ( last ) ; last = pos ; } deleteHandle ( pos ) ; } * head = NULL ; } int getHandleByIndex ( ) { c_handle * pos = head ; uint16_t i ; for ( i = 0 ; i < index ; i ++ ) { pos = pos -> next ; } return pos -> sock ; } char * getHandleName ( ) { while ( head ) { if ( head -> sock == sock ) { return head -> name ; } head = head -> next ; } return NULL ; } int getHandleSocket ( ) { while ( head ) { if ( ! strcmp ( head -> name , name ) ) { return head -> sock ; } head = head -> next ; } return - 1 ; } int removeHandle ( ) { c_handle * cur = * head ; c_handle * last = * head ; if ( sock < 3 ) { return - 1 ; } if ( cur ) { if ( cur -> sock == sock ) { * head = cur -> next ; deleteHandle ( cur ) ; return 0 ; } cur = * head ; } while ( cur ) { if ( cur -> sock == sock ) { last -> next = cur -> next ; deleteHandle ( cur ) ; return 0 ; } last = cur ; cur = cur -> next ; } return - 1 ; } int addHandle ( ) { c_handle * pos = * head ; if ( sock < 3 || - 1 != getHandleSocket ( * head , name ) ) { return - 1 ; } if ( ! * head ) { * head = calloc ( 1 , sizeof ( c_handle ) ) ; ( * head ) -> sock = sock ; strcpy ( ( * head ) -> name , name ) ; } else { while ( pos -> next ) { pos = pos -> next ; } pos -> next = calloc ( 1 , sizeof ( c_handle ) ) ; pos = pos -> next ; pos -> sock = sock ; strcpy ( pos -> name , name ) ; } return 0 ; } 
========== 17 ==========
(1) FILE: ../../packets.c LINES:129:6 TOKENS:653:702 DIST:0.0

case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : 
(2) FILE: ../../packets.c LINES:136:6 TOKENS:710:760 DIST:1.4

case FLAG5 : raw -> dest_handle_len = * ( pos ++ ) ; raw -> dest_handle_name = calloc ( raw -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> dest_handle_name , pos , raw -> dest_handle_len ) ; pos += raw -> dest_handle_len ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : raw -> src_handle_len = * ( pos ++ ) ; raw -> src_handle_name = calloc ( raw -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; memcpy ( raw -> src_handle_name , pos , raw -> src_handle_len ) ; pos += raw -> src_handle_len ; 
========== 18 ==========
(1) FILE: ../../server.c LINES:104:6 TOKENS:385:444 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
(2) FILE: ../../server.c LINES:120:6 TOKENS:494:553 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
========== 19 ==========
(1) FILE: ../../server.c LINES:104:6 TOKENS:385:444 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
(2) FILE: ../../cclient.c LINES:48:11 TOKENS:151:214 DIST:1.7

static void init ( ) { ; raw -> type = FLAG1 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) ; raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> src_handle_name , name , strlen ( name ) ) ; construct_packet ( rdy_send , raw ) ; write ( sock , rdy_send , raw -> packet_len ) ; destroy_raw_packet ( raw ) ; destroy_rdy_packet ( rdy_send ) ; destroy_rdy_packet ( rdy_rec ) ; tcgetattr ( STDIN_FILENO , & old ) ; cur = old ; cur . c_lflag &= ~ ICANON ; tcsetattr ( STDIN_FILENO , TCSANOW , & cur ) ; FD_ZERO ( & readfd ) ; FD_SET ( sock , & readfd ) ; select ( sock + 1 , & readfd , NULL , NULL , NULL ) ; process ( ) ; } 
(3) FILE: ../../server.c LINES:120:6 TOKENS:494:553 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; 
(4) FILE: ../../cclient.c LINES:147:9 TOKENS:628:692 DIST:3.0

if ( dest_name ) { raw -> type = FLAG5 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) + 1 + strlen ( name ) + strlen ( raw -> message ) ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; strcpy ( raw -> dest_handle_name , dest_name ) ; } else { raw -> type = FLAG4 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) + strlen ( raw -> message ) ; } 
========== 20 ==========
(1) FILE: ../../server.c LINES:104:5 TOKENS:383:433 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; 
(2) FILE: ../../server.c LINES:120:5 TOKENS:492:542 DIST:0.0

case JOIN_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG2 ; break ; case ALREADY_EXISTS : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG3 ; break ; case NO_RECIPIENT : raw -> type = FLAG7 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) ; break ; case EXIT_ACK : raw -> packet_len = OFFSET_HANDLE_LEN ; raw -> type = FLAG9 ; break ; case NUM_CLIENTS : raw -> packet_len = OFFSET_HANDLE_LEN + sizeof ( uint32_t ) ; raw -> type = FLAG11 ; raw -> to_be_sent = num_clients ; break ; case LIST_CLIENTS : raw -> type = FLAG12 ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; memcpy ( raw -> dest_handle_name , dest_name , strlen ( dest_name ) ) ; 
(3) FILE: ../../cclient.c LINES:157:6 TOKENS:693:745 DIST:3.2

raw -> message = calloc ( MAX_INPUT_SIZE + 1 , sizeof ( char ) ) ; if ( ! isEmpty ) { cont = get_message ( raw -> message ) ; } if ( dest_name ) { raw -> type = FLAG5 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( dest_name ) + 1 + strlen ( name ) + strlen ( raw -> message ) ; raw -> dest_handle_len = strlen ( dest_name ) ; raw -> dest_handle_name = calloc ( strlen ( dest_name ) + 1 , sizeof ( char ) ) ; strcpy ( raw -> dest_handle_name , dest_name ) ; } else { raw -> type = FLAG4 ; raw -> packet_len = OFFSET_HANDLE_NAME + strlen ( name ) + strlen ( raw -> message ) ; } raw -> src_handle_len = strlen ( name ) ; raw -> src_handle_name = calloc ( strlen ( name ) + 1 , sizeof ( char ) ) ; strcpy ( raw -> src_handle_name , name ) ; rdy = create_rdy_packet ( raw -> packet_len ) ; construct_packet ( rdy , raw ) ; 
