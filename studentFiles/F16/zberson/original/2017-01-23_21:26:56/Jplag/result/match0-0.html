<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>server.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>server.c</CENTER></H3><HR>
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

#include &quot;testing.h&quot;

#include &quot;lib.h&quot;
#include &quot;packets.h&quot;
#include &quot;connection.h&quot;
#include &quot;handle.h&quot;

static uint16_t port;
static int server_socket;
<A NAME="0"></A>static c_handle* clients;
static uint16_t num_clients;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match0-1.html#0',3,'match0-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>static void print_usage(const char** argv) {
   fprintf(stderr, &quot;usage: %s [port]\n&quot;, *argv);
   exit(-1);
}

static void parse_args(int argc, const char** argv) {
   if(argc &gt; 2) {
      print_usage(argv);
   }</B></FONT>

   if(argc == 2) {
      port = strtol(*(argv + 1), NULL, 10);
      if(!port) {
         fprintf(stderr, &quot;error: invalid port number\n&quot;);
         print_usage(argv);
      }
   }

   else {
      port = 0;
   }
}

static void init() {
   server_socket = tcpServerSetup(port);
   clients = NULL;
}

static int next_readfd(fd_set* set, c_handle* head, uint16_t index) {
   uint16_t i;
   int tmp_sock;

   for(i = index; ; i++) {
      tmp_sock = getHandleByIndex(head, i);
      if(FD_ISSET(tmp_sock, set)) {
         return tmp_sock;
      }
   }
}

static void reset_readfd(fd_set* set, c_handle* head) {
   uint16_t i;
   int tmp_sock;

   FD_ZERO(set);
   FD_SET(server_socket, set);
   for(i = 0; i &lt; num_clients; i++) {
      tmp_sock = getHandleByIndex(head, i);
      FD_SET(tmp_sock, set);
   }
}

static void send_message(int socket, rdy_packet* packet, uint16_t len) {
   write(socket, packet, len);
}

static void broadcast_message(rdy_packet* packet, uint16_t len, int exclude) {
   int i;
   int send_sock;

   for(i = 0; i &lt; num_clients; i++) {
      send_sock = getHandleByIndex(clients, i);
      if(send_sock != exclude) {
         send_message(send_sock, packet, len);
      }
   }   
}

static void send_state(int err_socket, int state, char* dest_name) {
   raw_packet* raw = create_raw_packet();
   rdy_packet* rdy = NULL;

   switch(state) {
      case JOIN_ACK:
         raw-&gt;packet_len = OFFSET_HANDLE_LEN;
         raw-&gt;type = FLAG2;
         break;
      case ALREADY_EXISTS:
         raw-&gt;packet_len = OFFSET_HANDLE_LEN;
         raw-&gt;type = FLAG3;
         break;
      case NO_RECIPIENT:
         raw-&gt;type = FLAG7;
         raw-&gt;dest_handle_len = strlen(dest_name);
         raw-&gt;dest_handle_name = calloc(strlen(dest_name) + 1, sizeof(char));
         memcpy(raw-&gt;dest_handle_name, dest_name, strlen(dest_name));
         raw-&gt;packet_len = OFFSET_HANDLE_NAME + strlen(dest_name);
         break;
      case EXIT_ACK:
         raw-&gt;packet_len = OFFSET_HANDLE_LEN;
         raw-&gt;type = FLAG9;
         break;
      case NUM_CLIENTS:
         raw-&gt;packet_len = OFFSET_HANDLE_LEN + sizeof(uint32_t);
         raw-&gt;type = FLAG11;
         raw-&gt;to_be_sent = num_clients;
         break;
      case LIST_CLIENTS:
         raw-&gt;type = FLAG12;
         raw-&gt;dest_handle_len = strlen(dest_name);
         raw-&gt;dest_handle_name = calloc(strlen(dest_name) + 1, sizeof(char));
         memcpy(raw-&gt;dest_handle_name, dest_name, strlen(dest_name));
         raw-&gt;packet_len = OFFSET_HANDLE_NAME + strlen(dest_name);
         break;
      default:
         break;
   }
   rdy = create_rdy_packet(raw-&gt;packet_len);
   construct_packet(rdy, raw);
   send_message(err_socket, rdy, raw-&gt;packet_len);

   destroy_raw_packet(raw);
   destroy_rdy_packet(rdy);
}

static void process_client(int client) {
   int status;
   raw_packet* rec_raw = create_raw_packet();
   rdy_packet* rec_rdy = create_rdy_packet(MAX_PACKET_LEN);
   rdy_packet* send_rdy = create_rdy_packet(MAX_PACKET_LEN);   
   int recipient = 0;
   int tmp;
   int i;
   char* name;

   status = read(client, rec_rdy, MAX_PACKET_LEN);
   if(status &lt; 0) {
      perror(&quot;read call&quot;);
   }
   else if(!status) {
      shutdown(client, SHUT_RDWR);
      removeHandle(&amp;clients, client);
      num_clients--;
   }
   else {
      status = deconstruct_packet(rec_raw, rec_rdy);
      if(status) {
         fprintf(stderr, &quot;error: could not read incoming packet\n&quot;);
         exit(-12);
      }
      else {
         deconstruct_packet(rec_raw, rec_rdy);
         switch (rec_raw-&gt;type) {
            case FLAG4:
               tmp = getHandleSocket(clients, rec_raw-&gt;src_handle_name);
               broadcast_message(rec_rdy, rec_raw-&gt;packet_len, tmp);
               break;
            case FLAG5:
               recipient = getHandleSocket(clients, rec_raw-&gt;dest_handle_name);
               if(-1 != recipient) {
                  send_message(recipient, rec_rdy, rec_raw-&gt;packet_len);
               }
               else {
                  send_state(client, NO_RECIPIENT, rec_raw-&gt;dest_handle_name);
               }
               break;
            case FLAG8:
                  send_state(client, EXIT_ACK, NULL);
               break;
            case FLAG10:
                  send_state(client, NUM_CLIENTS, NULL);
                  for(i = 0; i &lt; num_clients; i++) {
                     tmp = getHandleByIndex(clients, i);
                     name = getHandleName(clients, tmp);
                     send_state(client, LIST_CLIENTS, name);
                  }
               break;
            default:
               break;
         }
      }
   }
   destroy_rdy_packet(rec_rdy);
   destroy_raw_packet(rec_raw);
   destroy_rdy_packet(send_rdy);
}

static void accept_client(c_handle** clients) {
   int status;
   raw_packet* rec_raw = create_raw_packet();
   rdy_packet* rec_rdy = create_rdy_packet(MAX_PACKET_LEN);
   raw_packet* send_raw = create_raw_packet();
   rdy_packet* send_rdy = create_rdy_packet(MAX_PACKET_LEN);   
   int client_socket;

   client_socket = tcpServerAccept(server_socket);
   status = read(client_socket, rec_rdy, MAX_PACKET_LEN);
   if(status &lt; 0) {
      perror(&quot;read call&quot;);
   }
   status = deconstruct_packet(rec_raw, rec_rdy);
   if(status) {
      fprintf(stderr, &quot;error: could not read incoming packet\n&quot;);
   }
   else {
      status = addHandle(clients, client_socket, rec_raw-&gt;src_handle_name);
      if(-1 == status) {
         send_state(client_socket, ALREADY_EXISTS, NULL);
      }
      else if(!status) {
         num_clients++;
         send_state(client_socket, JOIN_ACK, NULL);
      }
   }

   destroy_rdy_packet(rec_rdy);
   destroy_raw_packet(rec_raw);
   destroy_rdy_packet(send_rdy);
   destroy_raw_packet(send_raw);
}

static void test_receive() {
   int status = 0;
   int i;
   int client_sock;
   fd_set readfd;

   while(1) {
      reset_readfd(&amp;readfd, clients);
      status = select(FD_SETSIZE, &amp;readfd, NULL, NULL, NULL);
      if(!status) {
         fprintf(stderr, &quot;select returned prematurely\n&quot;);
      }
      else {
         if(FD_ISSET(server_socket, &amp;readfd)) {
            accept_client(&amp;clients);
            status--;
         }
         for(i = 0; i &lt; status; i++) {
            client_sock = next_readfd(&amp;readfd, clients, i);
            process_client(client_sock);
         }
      }
   }
}

int main(int argc, const char** argv) {
   parse_args(argc, argv);
   init();

   test_receive();
   
   return 0;
}
</PRE>
</BODY>
</HTML>
