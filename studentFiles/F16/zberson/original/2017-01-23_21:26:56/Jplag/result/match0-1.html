<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>cclient.c</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>cclient.c</CENTER></H3><HR>
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;termios.h&gt;
#include &lt;netdb.h&gt;

#include &quot;testing.h&quot;

#include &quot;cclient.h&quot;
#include &quot;lib.h&quot;
#include &quot;packets.h&quot;
#include &quot;connection.h&quot;

static char name[MAX_NAME_SIZE + 1];
static int sock = 0;
static struct termios old;
static struct termios cur;
<A NAME="0"></A>   
static void process();

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match0-0.html#0',2,'match0-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>static void print_usage(const char** argv) {
   printf(&quot;usage: %s &lt;client handle name&gt; &lt;Host IP&gt; &lt;port&gt;\n&quot;, *argv);
   exit(-1);
}

static void parse_args(int argc, const char** argv) {
   if(argc != 4) {
      print_usage(argv);
   }</B></FONT>

   sock = dns_lookup(*(argv + CMD_OFFSET_IP), *(argv + CMD_OFFSET_PORT));

   memset(name, '\0', MAX_NAME_SIZE + 1);
   strcpy(name, *(argv + CMD_OFFSET_NAME));
}

static void print_commands() {
   printf(&quot;usage: &lt;command&gt; [option]...\ncommands:\n&quot;);
   printf(&quot;\t%%M &lt;handle&gt; [text]\n\t%%B [text]\n&quot;);
   printf(&quot;\t%%L\n\t%%E\n&quot;);
}

static void init() {
   raw_packet* raw = create_raw_packet();
   rdy_packet* rdy_send = create_rdy_packet(MAX_PACKET_LEN);
   rdy_packet* rdy_rec = create_rdy_packet(MAX_PACKET_LEN);
   fd_set readfd;

   raw-&gt;type = FLAG1;
   raw-&gt;packet_len = OFFSET_HANDLE_NAME + strlen(name);
   raw-&gt;src_handle_len = strlen(name);
   raw-&gt;src_handle_name = calloc(strlen(name) + 1, sizeof(char));
   memcpy(raw-&gt;src_handle_name, name, strlen(name));
   
   construct_packet(rdy_send, raw);

   write(sock, rdy_send, raw-&gt;packet_len);
   
   destroy_raw_packet(raw);
   destroy_rdy_packet(rdy_send);
   destroy_rdy_packet(rdy_rec);

   tcgetattr(STDIN_FILENO, &amp;old);
   cur = old;
   cur.c_lflag &amp;= ~ICANON;
   tcsetattr(STDIN_FILENO, TCSANOW, &amp;cur);

   FD_ZERO(&amp;readfd);
   FD_SET(sock, &amp;readfd);
   select(sock + 1, &amp;readfd, NULL, NULL, NULL);
   process();
}

static void exit_prog() {
   printf(&quot;\n&quot;);
   fflush(stdout);
   tcsetattr(STDIN_FILENO, TCSANOW, &amp;old);
   exit(0);
}

static void request_exit() {
   raw_packet* raw = create_raw_packet();
   rdy_packet* rdy = create_rdy_packet(OFFSET_HANDLE_LEN);

   raw-&gt;packet_len = OFFSET_HANDLE_LEN;
   raw-&gt;type = FLAG8;
   construct_packet(rdy, raw);

   write(sock, rdy, OFFSET_HANDLE_LEN);

   destroy_raw_packet(raw);
   destroy_rdy_packet(rdy);
}

static void request_list() {
   raw_packet* raw = create_raw_packet();
   rdy_packet* rdy = create_rdy_packet(OFFSET_HANDLE_LEN);

   raw-&gt;packet_len = OFFSET_HANDLE_LEN;
   raw-&gt;type = FLAG10;
   construct_packet(rdy, raw);

   write(sock, rdy, OFFSET_HANDLE_LEN);

   destroy_raw_packet(raw);
   destroy_rdy_packet(rdy);
}

static BOOLEAN get_message(char* buf) {
   int i = 0;
   BOOLEAN result = TRUE;

   buf[i++] = fgetc(stdin);
   while('\n' != buf[i-1] &amp;&amp; i &lt; MAX_INPUT_SIZE) {
      buf[i++] = fgetc(stdin);
   }
   if('\n' == buf[i-1]) {
     i--;
     result = FALSE;
   }
   buf[i] = '\0';

   return result;
}

static void send_message(char* dest_name, BOOLEAN isEmpty) {
//loop whole function until all of message is parsed from input
   raw_packet* raw = create_raw_packet();
   rdy_packet* rdy;
   BOOLEAN cont;

//loop until cont FALSE: no more message to parse
   while(cont) {
      raw-&gt;message = calloc(MAX_INPUT_SIZE + 1, sizeof(char));
      if(!isEmpty) {
         cont = get_message(raw-&gt;message);
      }
      if(dest_name) {
         raw-&gt;type = FLAG5;
         raw-&gt;packet_len = OFFSET_HANDLE_NAME + strlen(dest_name) + 1
                       + strlen(name) + strlen(raw-&gt;message);
         raw-&gt;dest_handle_len = strlen(dest_name);
         raw-&gt;dest_handle_name = calloc(strlen(dest_name) + 1, sizeof(char));
         strcpy(raw-&gt;dest_handle_name, dest_name);
      }
      else {
         raw-&gt;type = FLAG4;
         raw-&gt;packet_len = OFFSET_HANDLE_NAME + strlen(name)
                            + strlen(raw-&gt;message);
      }
    
      raw-&gt;src_handle_len = strlen(name);
      raw-&gt;src_handle_name = calloc(strlen(name) + 1, sizeof(char));
      strcpy(raw-&gt;src_handle_name, name);
         
      rdy = create_rdy_packet(raw-&gt;packet_len);   
      construct_packet(rdy, raw);
    
      write(sock, rdy, raw-&gt;packet_len);
      raw = recycle_raw_packet(raw);
      destroy_rdy_packet(rdy);
      rdy = NULL;
   }
   destroy_raw_packet(raw);
   destroy_rdy_packet(rdy);
}

static void wait_for_input() {
   char tmp = '\0';
   
   while('\n' != tmp) {
      tmp = fgetc(stdin);
   }
}

static void prompt() {
   char input[IN_BUF] = {0};
   char cmd = '\0';
   int chars_read = 0;

   input[chars_read++] = fgetc(stdin);
   if('%' != input[0]) {
      cmd = '\0';
      if('\n' != input[0]) {
         wait_for_input();
      }
   }
   else {
      input[chars_read++] = fgetc(stdin);
      if('\n' != input[1]) {
         cmd = input[1];
         input[chars_read++] = fgetc(stdin);
      }
   }
   switch (cmd) {
      case 'm':
      case 'M':
         if(input[2] != ' ') {
            if(input[2] != '\n') {
               wait_for_input();
            }
            print_commands();
            break;
         }
         memset(input, '\0', 3);
         chars_read = 0;
         input[chars_read] = fgetc(stdin);
         while('\n' != input[chars_read] &amp;&amp; ' ' != input[chars_read]) {
            input[++chars_read] = fgetc(stdin);
         }
         if(chars_read == 0 &amp;&amp; '\n' == input[chars_read]) {
            print_commands();
         }
         else {
            if('\n' == input[chars_read]) {
               input[chars_read] = '\0';
               send_message(input, TRUE);
            }
            else {
               input[chars_read] = '\0';
               send_message(input, FALSE);
            }
         }
         break;
      case 'b':
      case 'B':
         if(input[2] == ' ') {
            memset(input, '\0', 3);
            send_message(NULL, FALSE);
         }
         else if(input[2] == '\n') {
            memset(input, '\0', 3);
            send_message(NULL, TRUE);
         }
         else {
            print_commands();
         }
         break;
      case 'l':
      case 'L':
         if(input[2] != '\n') {
            wait_for_input();
            print_commands();
         }
         else {
            request_list();
         }
         break;
      case 'e':
      case 'E':
         if('\n' != input[2]) {
            wait_for_input();
            print_commands();
         }
         else {
            request_exit();
         }
         break;
      default:
         print_commands();
         break;
   }
}

static void talk() {
   fd_set readfd;
   int status = 0;

   printf(&quot;$: &quot;);
   fflush(stdout);
   fflush(stdin);
   
   while(TRUE) {
      FD_ZERO(&amp;readfd);
      FD_SET(sock, &amp;readfd);
      FD_SET(0, &amp;readfd);

      status = select(sock + 1, &amp;readfd, NULL, NULL, NULL);
      if(-1 == status) {
         perror(&quot;select call&quot;);
      }
      if(FD_ISSET(sock, &amp;readfd)) {
         process();
      }
      if(FD_ISSET(0, &amp;readfd)) {
         tcsetattr(STDIN_FILENO, TCSANOW, &amp;old);
         prompt();
         tcsetattr(STDIN_FILENO, TCSANOW, &amp;cur);
      }
      status = 0;
      printf(&quot;$: &quot;);
      fflush(stdout);
      fflush(stdin);
   }
}

static void process() {
   rdy_packet* rdy = create_rdy_packet(MAX_PACKET_LEN);
   raw_packet* raw = create_raw_packet();
   int status;
   int to_process = 0;
   int i;
   int size = 0;

   status = read(sock, rdy, OFFSET_HANDLE_LEN);
   if(!status) {
      exit_prog();
   }
   if(*(rdy + OFFSET_FLAG) != FLAG12) {
      size = ntohs(*((uint16_t*)rdy)) - OFFSET_HANDLE_LEN;
   }
   else {
      status += read(sock, rdy + OFFSET_HANDLE_LEN, 1);
      size = *(rdy + OFFSET_HANDLE_LEN);
   }
   status = read(sock, rdy + status, size);
   deconstruct_packet(raw, rdy);

   switch(raw-&gt;type) {
      case FLAG2:
         talk();
         break;
      case FLAG3:
         printf(&quot;Handle already in use: %s&quot;, name);
         fflush(stdout);
         exit_prog();
         break;
      case FLAG4:
      case FLAG5:
         printf(&quot;\n%s: &quot;, raw-&gt;src_handle_name);
         printf(&quot;%s\n&quot;, raw-&gt;message);
         fflush(stdout);
         break;
      case FLAG7:
         printf(&quot;\nClient with handle %s does not exist.\n&quot;, raw-&gt;src_handle_name);
         fflush(stdout);
         break;
      case FLAG9:
         exit_prog();
         break;
      case FLAG11:
         to_process = raw-&gt;to_be_sent;
         printf(&quot;\nNumber of clients: %u\n&quot;, to_process);
         for(i = 0; i &lt; to_process; i++) {
            process();
         }
         fflush(stdout);
         break;
      case FLAG12:
         printf(&quot;\t%s\n&quot;, raw-&gt;src_handle_name);
         break;
      default:
         break;
   }
}

int main(int argc, const char** argv) {
   parse_args(argc, argv);
   init();

   return 0;
}
</PRE>
</BODY>
</HTML>
