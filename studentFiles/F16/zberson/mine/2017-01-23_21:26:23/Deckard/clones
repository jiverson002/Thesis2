========== 1 ==========
(1) FILE: ../../server.c LINES:74:7 TOKENS:394:460 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; 
(2) FILE: ../../server.c LINES:87:7 TOKENS:507:572 DIST:1.7

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; 
========== 2 ==========
(1) FILE: ../../packets.c LINES:113:6 TOKENS:744:793 DIST:3.2

case FLAG5 : a -> dest_handle_len = * ( d ++ ) ; memcpy ( a -> dest_handle_name , d , a -> dest_handle_len ) ; d += a -> dest_handle_len ; a -> dest_handle_name = calloc ( a -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : a -> src_handle_len = * ( d ++ ) ; memcpy ( a -> src_handle_name , d , a -> src_handle_len ) ; d += a -> src_handle_len ; a -> src_handle_name = calloc ( a -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; break ; default : 
(2) FILE: ../../packets.c LINES:109:5 TOKENS:685:734 DIST:1.0

case FLAG5 : a -> dest_handle_len = * ( d ++ ) ; memcpy ( a -> dest_handle_name , d , a -> dest_handle_len ) ; d += a -> dest_handle_len ; a -> dest_handle_name = calloc ( a -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; case FLAG1 : 
========== 3 ==========
(1) FILE: ../../connection.c LINES:36:8 TOKENS:195:252 DIST:2.0

struct sockaddr_in b ; int c = 0 ; int d = 0 ; socklen_t e = sizeof ( b ) ; d = socket ( 2 , SOCK_STREAM , 0 ) ; b . sin_family = 2 ; b . sin_addr . s_addr = ( ( in_addr_t ) 0 ) ; if ( d < 3 ) { perror ( "server socket call" ) ; exit ( - 2 ) ; } b . sin_port = htons ( a ) ; c = bind ( d , ( struct sockaddr * ) & b , e ) ; if ( c < 0 ) { perror ( "bind call" ) ; exit ( - 3 ) ; } c = listen ( d , 50 ) ; if ( c < 0 ) { perror ( "listen call" ) ; exit ( - 4 ) ; } c = getsockname ( d , ( struct sockaddr * ) & b , & e ) ; if ( c < 0 ) { perror ( "getsockname call" ) ; exit ( - 8 ) ; } 
(2) FILE: ../../connection.c LINES:31:8 TOKENS:159:215 DIST:0.0

struct sockaddr_in b ; int c = 0 ; int d = 0 ; socklen_t e = sizeof ( b ) ; d = socket ( 2 , SOCK_STREAM , 0 ) ; b . sin_family = 2 ; b . sin_addr . s_addr = ( ( in_addr_t ) 0 ) ; if ( d < 3 ) { perror ( "server socket call" ) ; exit ( - 2 ) ; } b . sin_port = htons ( a ) ; c = bind ( d , ( struct sockaddr * ) & b , e ) ; if ( c < 0 ) { perror ( "bind call" ) ; exit ( - 3 ) ; } c = listen ( d , 50 ) ; if ( c < 0 ) { perror ( "listen call" ) ; exit ( - 4 ) ; } 
========== 4 ==========
(1) FILE: ../../cclient.c LINES:256:8 TOKENS:1620:1671 DIST:2.4

case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , global_e ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , c -> src_handle_name ) ; printf ( "%s\n" , c -> message ) ; fflush ( stdout ) ; break ; case FLAG7 : printf ( "\nClient with handle %s does not exist.\n" , c -> src_handle_name ) ; fflush ( stdout ) ; break ; case FLAG9 : exit_prog ( ) ; 
(2) FILE: ../../cclient.c LINES:250:8 TOKENS:1588:1638 DIST:0.0

case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , global_e ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , c -> src_handle_name ) ; printf ( "%s\n" , c -> message ) ; 
========== 5 ==========
(1) FILE: ../../server.c LINES:91:4 TOKENS:531:583 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; 
(2) FILE: ../../cclient.c LINES:38:4 TOKENS:180:232 DIST:0.0

; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; 
========== 6 ==========
(1) FILE: ../../packets.c LINES:108:5 TOKENS:677:731 DIST:0.0

switch ( a -> type ) { case FLAG5 : a -> dest_handle_len = * ( d ++ ) ; memcpy ( a -> dest_handle_name , d , a -> dest_handle_len ) ; d += a -> dest_handle_len ; a -> dest_handle_name = calloc ( a -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : a -> src_handle_len = * ( d ++ ) ; memcpy ( a -> src_handle_name , d , a -> src_handle_len ) ; d += a -> src_handle_len ; a -> src_handle_name = calloc ( a -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; break ; default : break ; } 
(2) FILE: ../../packets.c LINES:113:4 TOKENS:736:790 DIST:3.5

case FLAG5 : a -> dest_handle_len = * ( d ++ ) ; memcpy ( a -> dest_handle_name , d , a -> dest_handle_len ) ; d += a -> dest_handle_len ; a -> dest_handle_name = calloc ( a -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : a -> src_handle_len = * ( d ++ ) ; memcpy ( a -> src_handle_name , d , a -> src_handle_len ) ; d += a -> src_handle_len ; a -> src_handle_name = calloc ( a -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; 
========== 7 ==========
(1) FILE: ../../cclient.c LINES:10:11 TOKENS:36:92 DIST:2.6
__uint64_t __bswap_64(__uint64_t a) /*  */{

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } 
(2) FILE: ../../server.c LINES:9:11 TOKENS:28:83 DIST:2.6
__uint64_t __bswap_64(__uint64_t a) /*  */{
return __builtin_bswap64(a); /* return __builtin_bswap64(__bsx) */

uint16_t global_b ; int global_d ; c_handle * global_a ; uint16_t global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { fprintf ( stderr , "usage: %s [port]\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a > 2 ) { print_usage ( b ) ; } if ( a == 2 ) { global_b = strtol ( * ( b + 1 ) , ( ( void * ) 0 ) , 10 ) ; if ( ! global_b ) { fprintf ( stderr , "error: invalid port number\n" ) ; print_usage ( b ) ; } } else { global_b = 0 ; } } 
========== 8 ==========
(1) FILE: ../../cclient.c LINES:154:9 TOKENS:987:1041 DIST:0.0

case 'm' : case 'M' : if ( b [ 2 ] != ' ' ) { if ( b [ 2 ] != '\n' ) { wait_for_input ( ) ; } print_commands ( ) ; break ; } memset ( b , '\0' , 3 ) ; a = 0 ; b [ a ] = fgetc ( stdin ) ; if ( a == 0 && '\n' == b [ a ] ) { print_commands ( ) ; } else { if ( '\n' == b [ a ] ) { b [ a ] = '\0' ; send_message ( b , TRUE ) ; } else { b [ a ] = '\0' ; send_message ( b , FALSE ) ; } } 
(2) FILE: ../../cclient.c LINES:159:8 TOKENS:1015:1067 DIST:3.2

if ( a == 0 && '\n' == b [ a ] ) { print_commands ( ) ; } else { if ( '\n' == b [ a ] ) { b [ a ] = '\0' ; send_message ( b , TRUE ) ; } else { b [ a ] = '\0' ; send_message ( b , FALSE ) ; } } 
========== 9 ==========
(1) FILE: ../../cclient.c LINES:54:10 TOKENS:338:395 DIST:0.0

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } void init ( ) { ; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; construct_packet ( a , c ) ; write ( global_a , a , c -> packet_len ) ; destroy_raw_packet ( c ) ; destroy_rdy_packet ( a ) ; destroy_rdy_packet ( b ) ; tcgetattr ( 0 , & global_d ) ; tcsetattr ( 0 , 0 , & global_b ) ; FD_ZERO ( & d ) ; FD_SET ( global_a , & d ) ; mySelect ( global_a + 1 , & d , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; global_c ( ) ; } void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( 0 , 0 , & global_d ) ; exit ( 0 ) ; } void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } 
(2) FILE: ../../cclient.c LINES:222:12 TOKENS:1412:1470 DIST:3.2

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } void init ( ) { ; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; construct_packet ( a , c ) ; write ( global_a , a , c -> packet_len ) ; destroy_raw_packet ( c ) ; destroy_rdy_packet ( a ) ; destroy_rdy_packet ( b ) ; tcgetattr ( 0 , & global_d ) ; tcsetattr ( 0 , 0 , & global_b ) ; FD_ZERO ( & d ) ; FD_SET ( global_a , & d ) ; mySelect ( global_a + 1 , & d , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; global_c ( ) ; } void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( 0 , 0 , & global_d ) ; exit ( 0 ) ; } void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } void request_list ( ) { raw_packet * a = create_raw_packet ( ) ; rdy_packet * b = create_rdy_packet ( 3 ) ; a -> packet_len = 3 ; a -> type = FLAG10 ; construct_packet ( b , a ) ; write ( global_a , b , 3 ) ; destroy_raw_packet ( a ) ; destroy_rdy_packet ( b ) ; } BOOLEAN get_message ( char * a ) { ; a [ b ++ ] = fgetc ( stdin ) ; while ( '\n' != a [ b - 1 ] && b < 1000 ) { a [ b ++ ] = fgetc ( stdin ) ; } if ( '\n' == a [ b - 1 ] ) { c = FALSE ; } a [ b ] = '\0' ; return c ; } void send_message ( ) { ; rdy_packet * e ; while ( d ) { c -> message = calloc ( 1000 + 1 , sizeof ( char ) ) ; if ( a ) { c -> type = FLAG5 ; c -> packet_len = 4 + strlen ( a ) + 1 + strlen ( global_e ) + strlen ( c -> message ) ; c -> dest_handle_len = strlen ( a ) ; c -> dest_handle_name = calloc ( strlen ( a ) + 1 , sizeof ( char ) ) ; strcpy ( c -> dest_handle_name , a ) ; } else { c -> type = FLAG4 ; c -> packet_len = 4 + strlen ( global_e ) + strlen ( c -> message ) ; } if ( ! b ) { d = get_message ( c -> message ) ; } c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; strcpy ( c -> src_handle_name , global_e ) ; e = create_rdy_packet ( c -> packet_len ) ; construct_packet ( e , c ) ; write ( global_a , e , c -> packet_len ) ; c = recycle_raw_packet ( c ) ; destroy_rdy_packet ( e ) ; e = ( ( void * ) 0 ) ; } destroy_raw_packet ( c ) ; destroy_rdy_packet ( e ) ; } void wait_for_input ( ) { char a = '\0' ; while ( '\n' != a ) { a = fgetc ( stdin ) ; } } void prompt ( ) { int a = 0 ; char b [ 255 ] = { 0 } ; char c = '\0' ; b [ a ++ ] = fgetc ( stdin ) ; if ( '%' != b [ 0 ] ) { c = '\0' ; if ( '\n' != b [ 0 ] ) { wait_for_input ( ) ; } } else { b [ a ++ ] = fgetc ( stdin ) ; if ( '\n' != b [ 1 ] ) { c = b [ 1 ] ; b [ a ++ ] = fgetc ( stdin ) ; } } switch ( c ) { case 'm' : case 'M' : if ( b [ 2 ] != ' ' ) { if ( b [ 2 ] != '\n' ) { wait_for_input ( ) ; } print_commands ( ) ; break ; } memset ( b , '\0' , 3 ) ; a = 0 ; b [ a ] = fgetc ( stdin ) ; if ( a == 0 && '\n' == b [ a ] ) { print_commands ( ) ; } else { if ( '\n' == b [ a ] ) { b [ a ] = '\0' ; send_message ( b , TRUE ) ; } else { b [ a ] = '\0' ; send_message ( b , FALSE ) ; } } while ( '\n' != b [ a ] && ' ' != b [ a ] ) { b [ ++ a ] = fgetc ( stdin ) ; } break ; case 'b' : case 'B' : if ( b [ 2 ] == ' ' ) { memset ( b , '\0' , 3 ) ; send_message ( ( ( void * ) 0 ) , FALSE ) ; } else if ( b [ 2 ] == '\n' ) { memset ( b , '\0' , 3 ) ; send_message ( ( ( void * ) 0 ) , TRUE ) ; } else { print_commands ( ) ; } break ; case 'l' : case 'L' : if ( b [ 2 ] != '\n' ) { wait_for_input ( ) ; print_commands ( ) ; } else { request_list ( ) ; } break ; case 'e' : case 'E' : if ( '\n' != b [ 2 ] ) { wait_for_input ( ) ; print_commands ( ) ; } else { request_exit ( ) ; } break ; default : print_commands ( ) ; break ; } } void talk ( ) { ; int b = 0 ; printf ( "$: " ) ; fflush ( stdout ) ; fflush ( stdin ) ; while ( TRUE ) { FD_ZERO ( & a ) ; FD_SET ( global_a , & a ) ; FD_SET ( 0 , & a ) ; b = mySelect ( global_a + 1 , & a , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; if ( - 1 == b ) { perror ( "select call" ) ; } if ( FD_ISSET ( global_a , & a ) ) { global_c ( ) ; } if ( FD_ISSET ( 0 , & a ) ) { tcsetattr ( 0 , 0 , & global_d ) ; prompt ( ) ; tcsetattr ( 0 , 0 , & global_b ) ; } b = 0 ; printf ( "$: " ) ; fflush ( stdout ) ; fflush ( stdin ) ; } } void process ( ) { rdy_packet * a = create_rdy_packet ( 1515 ) ; int b = 0 ; raw_packet * c = create_raw_packet ( ) ; int d ; int e ; int f = 0 ; d = read ( global_a , a , 3 ) ; if ( ! d ) { exit_prog ( ) ; } if ( * ( a + 2 ) != FLAG12 ) { f = ntohs ( * ( ( uint16_t * ) a ) ) - 3 ; } else { d += read ( global_a , a + 3 , 1 ) ; f = * ( a + 3 ) ; } d = read ( global_a , a + d , f ) ; deconstruct_packet ( c , a ) ; switch ( c -> type ) { case FLAG2 : talk ( ) ; break ; case FLAG3 : printf ( "Handle already in use: %s" , global_e ) ; fflush ( stdout ) ; exit_prog ( ) ; break ; case FLAG4 : case FLAG5 : printf ( "\n%s: " , c -> src_handle_name ) ; printf ( "%s\n" , c -> message ) ; fflush ( stdout ) ; break ; case FLAG7 : printf ( "\nClient with handle %s does not exist.\n" , c -> src_handle_name ) ; fflush ( stdout ) ; break ; case FLAG9 : exit_prog ( ) ; break ; case FLAG11 : b = c -> to_be_sent ; printf ( "\nNumber of clients: %u\n" , b ) ; fflush ( stdout ) ; for ( e = 0 ; e < b ; e ++ ) { global_c ( ) ; } break ; case FLAG12 : printf ( "\t%s\n" , c -> src_handle_name ) ; break ; default : break ; } } 
========== 10 ==========
(1) FILE: ../../server.c LINES:86:6 TOKENS:493:544 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; 
(2) FILE: ../../server.c LINES:74:6 TOKENS:392:441 DIST:3.5

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; 
========== 11 ==========
(1) FILE: ../../cclient.c LINES:161:10 TOKENS:1032:1091 DIST:3.2

case 'm' : case 'M' : if ( b [ 2 ] != ' ' ) { if ( b [ 2 ] != '\n' ) { wait_for_input ( ) ; } print_commands ( ) ; break ; } memset ( b , '\0' , 3 ) ; a = 0 ; b [ a ] = fgetc ( stdin ) ; if ( a == 0 && '\n' == b [ a ] ) { print_commands ( ) ; } else { if ( '\n' == b [ a ] ) { b [ a ] = '\0' ; send_message ( b , TRUE ) ; } else { b [ a ] = '\0' ; send_message ( b , FALSE ) ; } } while ( '\n' != b [ a ] && ' ' != b [ a ] ) { b [ ++ a ] = fgetc ( stdin ) ; } 
(2) FILE: ../../cclient.c LINES:157:9 TOKENS:999:1058 DIST:0.0

case 'm' : case 'M' : if ( b [ 2 ] != ' ' ) { if ( b [ 2 ] != '\n' ) { wait_for_input ( ) ; } print_commands ( ) ; break ; } memset ( b , '\0' , 3 ) ; a = 0 ; b [ a ] = fgetc ( stdin ) ; if ( a == 0 && '\n' == b [ a ] ) { print_commands ( ) ; } else { if ( '\n' == b [ a ] ) { b [ a ] = '\0' ; send_message ( b , TRUE ) ; } else { b [ a ] = '\0' ; send_message ( b , FALSE ) ; } } 
========== 12 ==========
(1) FILE: ../../packets.c LINES:111:4 TOKENS:708:766 DIST:0.0

case FLAG5 : a -> dest_handle_len = * ( d ++ ) ; memcpy ( a -> dest_handle_name , d , a -> dest_handle_len ) ; d += a -> dest_handle_len ; a -> dest_handle_name = calloc ( a -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : a -> src_handle_len = * ( d ++ ) ; memcpy ( a -> src_handle_name , d , a -> src_handle_len ) ; 
(2) FILE: ../../packets.c LINES:113:4 TOKENS:732:790 DIST:0.0

case FLAG5 : a -> dest_handle_len = * ( d ++ ) ; memcpy ( a -> dest_handle_name , d , a -> dest_handle_len ) ; d += a -> dest_handle_len ; a -> dest_handle_name = calloc ( a -> dest_handle_len + 1 , sizeof ( uint8_t ) ) ; case FLAG1 : case FLAG4 : case FLAG7 : case FLAG12 : a -> src_handle_len = * ( d ++ ) ; memcpy ( a -> src_handle_name , d , a -> src_handle_len ) ; d += a -> src_handle_len ; a -> src_handle_name = calloc ( a -> src_handle_len + 1 , sizeof ( uint8_t ) ) ; 
========== 13 ==========
(1) FILE: ../../server.c LINES:90:5 TOKENS:524:583 DIST:1.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; 
(2) FILE: ../../server.c LINES:77:5 TOKENS:413:471 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; 
========== 14 ==========
(1) FILE: ../../cclient.c LINES:102:7 TOKENS:633:697 DIST:2.8

if ( a ) { c -> type = FLAG5 ; c -> packet_len = 4 + strlen ( a ) + 1 + strlen ( global_e ) + strlen ( c -> message ) ; c -> dest_handle_len = strlen ( a ) ; c -> dest_handle_name = calloc ( strlen ( a ) + 1 , sizeof ( char ) ) ; strcpy ( c -> dest_handle_name , a ) ; } else { c -> type = FLAG4 ; c -> packet_len = 4 + strlen ( global_e ) + strlen ( c -> message ) ; } 
(2) FILE: ../../server.c LINES:77:5 TOKENS:413:471 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; 
(3) FILE: ../../server.c LINES:90:5 TOKENS:524:583 DIST:1.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; 
========== 15 ==========
(1) FILE: ../../server.c LINES:90:4 TOKENS:522:572 DIST:1.4

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; 
(2) FILE: ../../cclient.c LINES:109:6 TOKENS:700:750 DIST:3.5

c -> message = calloc ( 1000 + 1 , sizeof ( char ) ) ; if ( a ) { c -> type = FLAG5 ; c -> packet_len = 4 + strlen ( a ) + 1 + strlen ( global_e ) + strlen ( c -> message ) ; c -> dest_handle_len = strlen ( a ) ; c -> dest_handle_name = calloc ( strlen ( a ) + 1 , sizeof ( char ) ) ; strcpy ( c -> dest_handle_name , a ) ; } else { c -> type = FLAG4 ; c -> packet_len = 4 + strlen ( global_e ) + strlen ( c -> message ) ; } if ( ! b ) { d = get_message ( c -> message ) ; } c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; strcpy ( c -> src_handle_name , global_e ) ; 
(3) FILE: ../../server.c LINES:77:4 TOKENS:411:460 DIST:2.6

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; 
========== 16 ==========
(1) FILE: ../../cclient.c LINES:70:10 TOKENS:429:489 DIST:0.0

void request_list ( ) { raw_packet * a = create_raw_packet ( ) ; rdy_packet * b = create_rdy_packet ( 3 ) ; a -> packet_len = 3 ; a -> type = FLAG10 ; construct_packet ( b , a ) ; write ( global_a , b , 3 ) ; destroy_raw_packet ( a ) ; destroy_rdy_packet ( b ) ; } 
(2) FILE: ../../cclient.c LINES:60:10 TOKENS:368:428 DIST:0.0

void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } 
========== 17 ==========
(1) FILE: ../../server.c LINES:6:11 TOKENS:14:69 DIST:0.0
unsigned int __bswap_32(unsigned int a) /*  */{
return __builtin_bswap32(a); /* return __builtin_bswap32(__bsx) */
}
__uint64_t __bswap_64(__uint64_t a) /*  */{
return __builtin_bswap64(a); /* return __builtin_bswap64(__bsx) */

uint16_t global_b ; int global_d ; c_handle * global_a ; uint16_t global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { fprintf ( stderr , "usage: %s [port]\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a > 2 ) { print_usage ( b ) ; } if ( a == 2 ) { global_b = strtol ( * ( b + 1 ) , ( ( void * ) 0 ) , 10 ) ; if ( ! global_b ) { fprintf ( stderr , "error: invalid port number\n" ) ; print_usage ( b ) ; } } else { global_b = 0 ; } } 
(2) FILE: ../../cclient.c LINES:7:11 TOKENS:25:78 DIST:2.2
unsigned int __bswap_32(unsigned int a) /*  */{
return __builtin_bswap32(a); /* return __builtin_bswap32(__bsx) */
}
__uint64_t __bswap_64(__uint64_t a) /*  */{

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } 
========== 18 ==========
(1) FILE: ../../packets.c LINES:33:8 TOKENS:181:232 DIST:2.2

if ( a -> src_handle_name ) { free ( a -> src_handle_name ) ; a -> src_handle_name = ( ( void * ) 0 ) ; } if ( a -> dest_handle_name ) { free ( a -> dest_handle_name ) ; a -> dest_handle_name = ( ( void * ) 0 ) ; } if ( a -> message ) { free ( a -> message ) ; a -> message = ( ( void * ) 0 ) ; } 
(2) FILE: ../../packets.c LINES:28:9 TOKENS:148:205 DIST:0.0

void destroy_raw_packet ( ) { if ( a -> src_handle_name ) { free ( a -> src_handle_name ) ; a -> src_handle_name = ( ( void * ) 0 ) ; } if ( a -> dest_handle_name ) { free ( a -> dest_handle_name ) ; a -> dest_handle_name = ( ( void * ) 0 ) ; } if ( a -> message ) { free ( a -> message ) ; a -> message = ( ( void * ) 0 ) ; } free ( a ) ; } 
========== 19 ==========
(1) FILE: ../../server.c LINES:85:7 TOKENS:490:544 DIST:3.5

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; 
(2) FILE: ../../server.c LINES:73:7 TOKENS:389:441 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; 
========== 20 ==========
(1) FILE: ../../connection.c LINES:26:8 TOKENS:133:187 DIST:0.0

struct sockaddr_in b ; int c = 0 ; int d = 0 ; socklen_t e = sizeof ( b ) ; d = socket ( 2 , SOCK_STREAM , 0 ) ; b . sin_family = 2 ; b . sin_addr . s_addr = ( ( in_addr_t ) 0 ) ; if ( d < 3 ) { perror ( "server socket call" ) ; exit ( - 2 ) ; } b . sin_port = htons ( a ) ; c = bind ( d , ( struct sockaddr * ) & b , e ) ; if ( c < 0 ) { perror ( "bind call" ) ; exit ( - 3 ) ; } 
(2) FILE: ../../connection.c LINES:31:8 TOKENS:159:215 DIST:3.2

struct sockaddr_in b ; int c = 0 ; int d = 0 ; socklen_t e = sizeof ( b ) ; d = socket ( 2 , SOCK_STREAM , 0 ) ; b . sin_family = 2 ; b . sin_addr . s_addr = ( ( in_addr_t ) 0 ) ; if ( d < 3 ) { perror ( "server socket call" ) ; exit ( - 2 ) ; } b . sin_port = htons ( a ) ; c = bind ( d , ( struct sockaddr * ) & b , e ) ; if ( c < 0 ) { perror ( "bind call" ) ; exit ( - 3 ) ; } c = listen ( d , 50 ) ; if ( c < 0 ) { perror ( "listen call" ) ; exit ( - 4 ) ; } 
========== 21 ==========
(1) FILE: ../../cclient.c LINES:66:9 TOKENS:409:462 DIST:3.5

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } void init ( ) { ; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; construct_packet ( a , c ) ; write ( global_a , a , c -> packet_len ) ; destroy_raw_packet ( c ) ; destroy_rdy_packet ( a ) ; destroy_rdy_packet ( b ) ; tcgetattr ( 0 , & global_d ) ; tcsetattr ( 0 , 0 , & global_b ) ; FD_ZERO ( & d ) ; FD_SET ( global_a , & d ) ; mySelect ( global_a + 1 , & d , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; global_c ( ) ; } void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( 0 , 0 , & global_d ) ; exit ( 0 ) ; } void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } void request_list ( ) { raw_packet * a = create_raw_packet ( ) ; rdy_packet * b = create_rdy_packet ( 3 ) ; a -> packet_len = 3 ; a -> type = FLAG10 ; construct_packet ( b , a ) ; write ( global_a , b , 3 ) ; destroy_raw_packet ( a ) ; destroy_rdy_packet ( b ) ; } 
(2) FILE: ../../cclient.c LINES:56:9 TOKENS:347:401 DIST:0.0

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } void init ( ) { ; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; construct_packet ( a , c ) ; write ( global_a , a , c -> packet_len ) ; destroy_raw_packet ( c ) ; destroy_rdy_packet ( a ) ; destroy_rdy_packet ( b ) ; tcgetattr ( 0 , & global_d ) ; tcsetattr ( 0 , 0 , & global_b ) ; FD_ZERO ( & d ) ; FD_SET ( global_a , & d ) ; mySelect ( global_a + 1 , & d , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; global_c ( ) ; } void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( 0 , 0 , & global_d ) ; exit ( 0 ) ; } void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } 
========== 22 ==========
(1) FILE: ../../server.c LINES:89:5 TOKENS:519:572 DIST:1.4

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; d -> packet_len = 4 + strlen ( c ) ; break ; case - 9 : d -> packet_len = 3 ; d -> type = FLAG9 ; break ; case - 11 : d -> packet_len = 3 + sizeof ( uint32_t ) ; d -> to_be_sent = global_c ; d -> type = FLAG11 ; break ; case - 12 : d -> type = FLAG12 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; 
(2) FILE: ../../server.c LINES:77:4 TOKENS:409:460 DIST:0.0

case - 2 : d -> packet_len = 3 ; d -> type = FLAG2 ; break ; case - 3 : d -> packet_len = 3 ; d -> type = FLAG3 ; break ; case - 7 : d -> type = FLAG7 ; memcpy ( d -> dest_handle_name , c , strlen ( c ) ) ; d -> dest_handle_len = strlen ( c ) ; d -> dest_handle_name = calloc ( strlen ( c ) + 1 , sizeof ( char ) ) ; 
========== 23 ==========
(1) FILE: ../../cclient.c LINES:58:9 TOKENS:362:417 DIST:1.7

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } void init ( ) { ; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; construct_packet ( a , c ) ; write ( global_a , a , c -> packet_len ) ; destroy_raw_packet ( c ) ; destroy_rdy_packet ( a ) ; destroy_rdy_packet ( b ) ; tcgetattr ( 0 , & global_d ) ; tcsetattr ( 0 , 0 , & global_b ) ; FD_ZERO ( & d ) ; FD_SET ( global_a , & d ) ; mySelect ( global_a + 1 , & d , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; global_c ( ) ; } void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( 0 , 0 , & global_d ) ; exit ( 0 ) ; } void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } 
(2) FILE: ../../cclient.c LINES:66:9 TOKENS:409:462 DIST:2.4

char global_e [ 255 + 1 ] ; int global_a = 0 ; struct termios global_d ; struct termios global_b ; void global_c ; unsigned int __bswap_32 ( unsigned int a ) { ; } __uint64_t __bswap_64 ( __uint64_t a ) { ; } void print_usage ( char * * a ) { printf ( "usage: %s <client handle name> <Host IP> <port>\n" , * a ) ; exit ( - 1 ) ; } void parse_args ( int a , char * * b ) { if ( a != 4 ) { print_usage ( b ) ; } global_a = dns_lookup ( * ( b + 2 ) , * ( b + 3 ) ) ; memset ( global_e , '\0' , 255 + 1 ) ; strcpy ( global_e , * ( b + 1 ) ) ; } void print_commands ( ) { printf ( "usage: <command> [option]...\ncommands:\n" ) ; printf ( "\t%%M <handle> [text]\n\t%%B [text]\n" ) ; printf ( "\t%%L\n\t%%E\n" ) ; } void init ( ) { ; global_b = global_d ; c -> type = FLAG1 ; global_b . c_lflag &= ~ 2 ; c -> packet_len = 4 + strlen ( global_e ) ; c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; memcpy ( c -> src_handle_name , global_e , strlen ( global_e ) ) ; construct_packet ( a , c ) ; write ( global_a , a , c -> packet_len ) ; destroy_raw_packet ( c ) ; destroy_rdy_packet ( a ) ; destroy_rdy_packet ( b ) ; tcgetattr ( 0 , & global_d ) ; tcsetattr ( 0 , 0 , & global_b ) ; FD_ZERO ( & d ) ; FD_SET ( global_a , & d ) ; mySelect ( global_a + 1 , & d , ( ( void * ) 0 ) , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; global_c ( ) ; } void exit_prog ( ) { printf ( "\n" ) ; fflush ( stdout ) ; tcsetattr ( 0 , 0 , & global_d ) ; exit ( 0 ) ; } void request_exit ( ) { rdy_packet * a = create_rdy_packet ( 3 ) ; raw_packet * b = create_raw_packet ( ) ; b -> packet_len = 3 ; b -> type = FLAG8 ; construct_packet ( a , b ) ; write ( global_a , a , 3 ) ; destroy_raw_packet ( b ) ; destroy_rdy_packet ( a ) ; } void request_list ( ) { raw_packet * a = create_raw_packet ( ) ; rdy_packet * b = create_rdy_packet ( 3 ) ; a -> packet_len = 3 ; a -> type = FLAG10 ; construct_packet ( b , a ) ; write ( global_a , b , 3 ) ; destroy_raw_packet ( a ) ; destroy_rdy_packet ( b ) ; } 
========== 24 ==========
(1) FILE: ../../cclient.c LINES:98:5 TOKENS:581:641 DIST:3.3

c -> message = calloc ( 1000 + 1 , sizeof ( char ) ) ; if ( a ) { c -> type = FLAG5 ; c -> packet_len = 4 + strlen ( a ) + 1 + strlen ( global_e ) + strlen ( c -> message ) ; c -> dest_handle_len = strlen ( a ) ; c -> dest_handle_name = calloc ( strlen ( a ) + 1 , sizeof ( char ) ) ; strcpy ( c -> dest_handle_name , a ) ; } else { c -> type = FLAG4 ; c -> packet_len = 4 + strlen ( global_e ) + strlen ( c -> message ) ; } 
(2) FILE: ../../cclient.c LINES:93:9 TOKENS:567:632 DIST:0.0

void send_message ( ) { ; rdy_packet * e ; while ( d ) { c -> message = calloc ( 1000 + 1 , sizeof ( char ) ) ; if ( a ) { c -> type = FLAG5 ; c -> packet_len = 4 + strlen ( a ) + 1 + strlen ( global_e ) + strlen ( c -> message ) ; c -> dest_handle_len = strlen ( a ) ; c -> dest_handle_name = calloc ( strlen ( a ) + 1 , sizeof ( char ) ) ; strcpy ( c -> dest_handle_name , a ) ; } else { c -> type = FLAG4 ; c -> packet_len = 4 + strlen ( global_e ) + strlen ( c -> message ) ; } if ( ! b ) { d = get_message ( c -> message ) ; } c -> src_handle_len = strlen ( global_e ) ; c -> src_handle_name = calloc ( strlen ( global_e ) + 1 , sizeof ( char ) ) ; strcpy ( c -> src_handle_name , global_e ) ; e = create_rdy_packet ( c -> packet_len ) ; construct_packet ( e , c ) ; write ( global_a , e , c -> packet_len ) ; c = recycle_raw_packet ( c ) ; destroy_rdy_packet ( e ) ; e = ( ( void * ) 0 ) ; } destroy_raw_packet ( c ) ; destroy_rdy_packet ( e ) ; } 
